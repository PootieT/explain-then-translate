[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"()\") #t 0.001)\n    (check-within (candidate \"(()())\") #t 0.001)\n    (check-within (candidate \"()()(()())()\") #t 0.001)\n    (check-within (candidate \"()()((()()())())(()()(()))\") #t 0.001)\n    (check-within (candidate \"((()())))\") #f 0.001)\n    (check-within (candidate \")(()\") #f 0.001)\n    (check-within (candidate \"(\") #f 0.001)\n    (check-within (candidate \"((((\") #f 0.001)\n    (check-within (candidate \")\") #f 0.001)\n    (check-within (candidate \"(()\") #f 0.001)\n    (check-within (candidate \"()()(()())())(()\") #f 0.001)\n    (check-within (candidate \"()()(()())()))()\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction correct_bracketing(brackets){\n  let depth = 0;\n  for(let b of brackets){\n    if(b === '('){\n      depth += 1;\n    }else{\n      depth -= 1;\n    }\n    if(depth < 0){\n      return false;\n    }\n  }\n  return depth == 0;\n}\n\n### Explanation\n\nThe code is an implementation of a function `correct_bracketing` that takes a string of brackets and returns true if the brackets are balanced and false otherwise. \n\n1. The function takes a string of brackets as an argument.\n2. A variable `depth` is initialized to 0.\n3. A for loop is used to iterate over each character in the string of brackets.\n4. If the current character is an opening bracket (i.e. '('), the `depth` variable is incremented by 1.\n5. If the current character is a closing bracket (i.e. ')'), the `depth` variable is decremented by 1.\n6. If the `depth` variable ever becomes negative, it means that there is a closing bracket without a corresponding opening bracket, so the function returns false.\n7. After the loop has finished, if the `depth` variable is 0, it means that all opening brackets have a corresponding closing bracket, so the function returns true. Otherwise, it returns false. \n\n\n### Racket version\n\n#lang racket\n\n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triangle_area a h)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 5 3) 7.5 0.001)\n    (check-within (candidate 2 2) 2.0 0.001)\n    (check-within (candidate 10 8) 40.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction triangle_area(a, h){\n  return a*h/2;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `triangle_area` that takes two parameters `a` and `h`. The function returns the area of a triangle given the base `a` and the height `h`. The area of a triangle is calculated by multiplying the base by the height and dividing the result by two. The function returns the result of this calculation. \n\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a h)\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (special_factorial n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate special_factorial))\n    (check-within (candidate 4) 288 0.001)\n    (check-within (candidate 5) 34560 0.001)\n    (check-within (candidate 7) 125411328000 0.001)\n    (check-within (candidate 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction special_factorial(n){\n  let fact_i = 1;\n  let special_fact = 1;\n  for(let i=1; i<n+1; i++){\n    fact_i *= i;\n    special_fact *= fact_i;\n  }\n  return special_fact;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `special_factorial` that takes one argument `n`. The function returns a special factorial of `n`. \n\nThe special factorial of `n` is defined as the product of factorials of all numbers from 1 to `n`. \n\nThe function initializes two variables `fact_i` and `special_fact` to 1. \n\nIt then enters a loop that iterates from 1 to `n` (inclusive). \n\nIn each iteration, it multiplies `fact_i` by `i` and then multiplies `special_fact` by `fact_i`. \n\nFinally, it returns `special_fact`.\n\n\n### Racket version\n\n#lang racket\n\n(define (special_factorial n)\n"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_smallest_integers lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_136_largest_smallest_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)\n    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)\n    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)\n    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)\n    (check-within (candidate (list )) (list #f #f) 0.001)\n    (check-within (candidate (list 0)) (list #f #f) 0.001)\n    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)\n    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)\n    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)\n    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction largest_smallest_integers(lst){\n  let smallest = lst.filter(x => x < 0)\n  let largest = lst.filter(x => x > 0)\n  return [smallest.length ? Math.max(...smallest) : null, largest.length ? Math.min(...largest) : null]\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns a list of two integers, the largest negative integer in the input list and the smallest positive integer in the input list. If the input list does not contain any negative integers, the first element of the output list is null. If the input list does not contain any positive integers, the second element of the output list is null.\n\nThe function works as follows:\n\n1. The function takes a list of integers as input and assigns it to the variable `lst`.\n2. The function filters the input list to create a new list `smallest` that contains only the negative integers in the input list. This is done using the `filter` method of the input list, which takes a function as an argument that returns `true` if the element should be included in the filtered list and `false` otherwise. In this case, the function checks if the element is less than zero (`x < 0`).\n3. The function filters the input list to create a new list `largest` that contains only the positive integers in the input list. This is done using the same method as in step 2, but with a different condition (`x > 0`).\n4. The function returns a list containing the largest negative integer in the `smallest` list (if it exists) and the smallest positive integer in the `largest` list (if it exists). This is done using the `Math.max` and `Math.min` functions, which return the maximum and minimum value in an array, respectively. If the `smallest` list is empty, the first element of the output list is null. If the `largest` list is empty, the second element of the output list is null.\n\n\n### Racket version\n\n#lang racket\n\n(define (largest_smallest_integers lst)\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (move_one_ball arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate move_one_ball))\n    (check-within (candidate (list 3 4 5 1 2)) #t 0.001)\n    (check-within (candidate (list 3 5 10 1 2)) #t 0.001)\n    (check-within (candidate (list 4 3 1 2)) #f 0.001)\n    (check-within (candidate (list 3 5 4 1 2)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction move_one_ball(arr){\n  if(arr.length==0){\n    return true;\n  }\n  let sorted_array=arr.slice().sort((a,b) => a-b);\n  let my_arr=[];\n  \n  let min_value=Math.min(...arr);\n  let min_index=arr.indexOf(min_value);\n  my_arr=arr.slice(min_index).concat(arr.slice(0,min_index));\n  for(let i=0; i<arr.length; i++){\n    if(my_arr[i]!=sorted_array[i]){\n      return false;\n    }\n  }\n  return true;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `move_one_ball` that takes an array of integers as input and returns a boolean value. The function checks if it is possible to sort the array by moving only one element to a different position. If it is possible, the function returns `true`, otherwise it returns `false`.\n\nThe function starts by checking if the input array is empty. If it is, the function returns `true` because an empty array is already sorted. If the array is not empty, the function creates a copy of the input array and sorts it in ascending order. The sorted array is stored in a variable called `sorted_array`.\n\nNext, the function initializes an empty array called `my_arr`. The function finds the minimum value in the input array using the `Math.min` function and stores it in a variable called `min_value`. The function finds the index of the minimum value in the input array using the `indexOf` function and stores it in a variable called `min_index`.\n\nThe function creates a new array called `my_arr` by concatenating two slices of the input array. The first slice starts at the index of the minimum value and goes to the end of the array. The second slice starts at the beginning of the array and goes up to, but not including, the index of the minimum value. This creates a new array where the minimum value is at the beginning and the rest of the values are shifted to the right.\n\nFinally, the function loops through the input array and compares each element of `my_arr` to the corresponding element of `sorted_array`. If any of the elements are different, the function returns `false` because it is not possible to sort the array by moving only one element. If all of the elements are the same, the function returns `true` because it is possible to sort the array by moving only one element.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (move_one_ball arr)\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (digits n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n    (check-within (candidate 5) 5 0.001)\n    (check-within (candidate 54) 5 0.001)\n    (check-within (candidate 120) 1 0.001)\n    (check-within (candidate 5014) 5 0.001)\n    (check-within (candidate 98765) 315 0.001)\n    (check-within (candidate 5576543) 2625 0.001)\n    (check-within (candidate 2468) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction digits(n){\n  let product = 1;\n  let odd_count = 0;\n  for(let digit of String(n)){\n    let int_digit = Number(digit);\n    if(int_digit%2 === 1){\n      product *= int_digit;\n      odd_count += 1;\n    }\n  }\n  return odd_count === 0 ? 0 : product;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `digits` that takes a single argument `n`. The function returns the product of all odd digits in `n`. If there are no odd digits in `n`, the function returns `0`.\n\n1. `function digits(n){` - This line declares the function `digits` that takes a single argument `n`.\n2. `let product = 1;` - This line declares a variable `product` and initializes it to `1`.\n3. `let odd_count = 0;` - This line declares a variable `odd_count` and initializes it to `0`.\n4. `for(let digit of String(n)){` - This line starts a `for` loop that iterates over each character in the string representation of `n`.\n5. `let int_digit = Number(digit);` - This line converts the current character to a number and assigns it to the variable `int_digit`.\n6. `if(int_digit%2 === 1){` - This line checks if `int_digit` is odd.\n7. `product *= int_digit;` - This line multiplies `product` by `int_digit` if it is odd.\n8. `odd_count += 1;` - This line increments `odd_count` if `int_digit` is odd.\n9. `}` - This line ends the `if` statement.\n10. `}` - This line ends the `for` loop.\n11. `return odd_count === 0 ? 0 : product;` - This line returns `0` if there are no odd digits in `n`, otherwise it returns the product of all odd digits in `n`. The `?` and `:` are part of a ternary operator that is used to conditionally return either `0` or `product`. \n\n\n### Racket version\n\n#lang racket\n\n(define (digits n)\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fib4 n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib4))\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 28 0.001)\n    (check-within (candidate 10) 104 0.001)\n    (check-within (candidate 12) 386 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction fib4(n){\n    let results = [0, 0, 2, 0];\n    if (n < 4){\n        return results[n];\n    }\n\n    for (let i = 4; i <= n; i++){\n        let sum = results[0] + results[1] + results[2] + results[3];\n        results.shift();\n        results.push(sum);\n    }\n\n    return results[3];\n}\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. The function `fib4` takes an integer `n` as input and returns the `n`th number in the Fibonacci sequence. \n\nThe Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding numbers. The sequence starts with 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, and so on.\n\nThe function initializes an array `results` with the first four numbers in the sequence: 0, 0, 2, 0. The first two zeros are used to calculate the fourth number in the sequence, which is 2. The last zero is a placeholder that will be replaced with the next number in the sequence.\n\nIf `n` is less than 4, the function returns the corresponding number in the `results` array. Otherwise, the function enters a loop that calculates the next number in the sequence. The loop starts at 4 and continues until `n`. \n\nIn each iteration of the loop, the function calculates the sum of the four numbers in the `results` array and stores it in a variable `sum`. The function then removes the first number in the `results` array using the `shift` method, and adds the `sum` to the end of the array using the `push` method. This effectively shifts the array to the left and replaces the last zero with the next number in the sequence.\n\nAfter the loop completes, the function returns the last number in the `results` array, which is the `n`th number in the Fibonacci sequence. In this implementation, the `n`th number is always stored in the fourth position of the `results` array, so the function returns `results[3]`.\n\n\n### Racket version\n\n#lang racket\n\n(define (fib4 n)\n"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (order_by_points nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_145_order_by_points.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate order_by_points))\n    (check-within (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11) 0.001)\n    (check-within (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -11 -32 43 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9) 0.001)\n    (check-within (candidate (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction order_by_points(nums){\n  function digits_sum(n){\n    let neg = 1;\n    if (n < 0) [n, neg] = [-1 * n, -1];\n    n = Array.from(String(n), Number);\n    n[0] = n[0] * neg;\n    return n.reduce((a, b) => a + b, 0);\n  }\n  return nums.sort((a, b) => digits_sum(a) - digits_sum(b));\n}\n\n### Explanation\n\nThe code is an implementation of a function that sorts an array of integers by the sum of their digits. \n\n1. The function `order_by_points` takes an array of integers as an argument.\n2. The function `digits_sum` takes an integer as an argument and returns the sum of its digits.\n3. The `neg` variable is initialized to 1.\n4. If the integer is negative, the `neg` variable is set to -1 and the integer is converted to its absolute value.\n5. The integer is converted to an array of digits using the `Array.from` method and the `Number` function.\n6. If the integer was negative, the first digit in the array is multiplied by -1 to restore the original sign.\n7. The sum of the digits is computed using the `reduce` method.\n8. The `nums` array is sorted using the `sort` method and a comparison function that compares the sum of the digits of each integer.\n\n\n### Racket version\n\n#lang racket\n\n(define (order_by_points nums)\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_happy s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n    (check-within (candidate \"a\") #f 0.001)\n    (check-within (candidate \"aa\") #f 0.001)\n    (check-within (candidate \"abcd\") #t 0.001)\n    (check-within (candidate \"aabb\") #f 0.001)\n    (check-within (candidate \"adb\") #t 0.001)\n    (check-within (candidate \"xyy\") #f 0.001)\n    (check-within (candidate \"iopaxpoi\") #t 0.001)\n    (check-within (candidate \"iopaxioi\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_happy(s){\n  if(s.length < 3) return false;\n  for(let i = 0; i < s.length - 2; i++){\n    if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2]) return false;\n  }\n  return true;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `is_happy` that takes a string `s` as input and returns `true` if the string is happy and `false` otherwise. A string is considered happy if there are no adjacent characters that are the same and no characters that are separated by one character that are the same.\n\nThe function first checks if the length of the string is less than 3. If it is, the function returns `false` because a string with less than 3 characters cannot be happy.\n\nIf the length of the string is greater than or equal to 3, the function enters a `for` loop that iterates over each character in the string except for the last two. The loop checks if any of the following conditions are true:\n\n1. The current character is the same as the next character.\n2. The next character is the same as the character after it.\n3. The current character is the same as the character two positions ahead.\n\nIf any of these conditions are true, the function returns `false` because the string is not happy.\n\nIf none of the conditions are true, the function returns `true` because the string is happy.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_happy s)\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (circular_shift x shift)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n    (check-within (candidate 100 2) \"001\" 0.001)\n    (check-within (candidate 12 2) \"12\" 0.001)\n    (check-within (candidate 97 8) \"79\" 0.001)\n    (check-within (candidate 12 1) \"21\" 0.001)\n    (check-within (candidate 11 101) \"11\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction circular_shift(x, shift){\n  let s = String(x);\n  if(shift > s.length){\n    return s.split(\"\").reverse().join(\"\");\n  }else{\n    return s.slice(s.length-shift) + s.slice(0, s.length-shift);\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a circular shift function in JavaScript. The function takes two arguments, `x` and `shift`. `x` is the number to be shifted and `shift` is the number of positions to shift `x` to the left. \n\nThe function first converts the number `x` to a string and assigns it to the variable `s`. \n\nThe function then checks if the value of `shift` is greater than the length of the string `s`. If it is, the function reverses the string `s`, converts it back to a number and returns it. This is because if the shift value is greater than the length of the string, the circular shift will wrap around the entire string and end up back where it started. \n\nIf the value of `shift` is less than or equal to the length of the string `s`, the function slices the string `s` into two parts: the first part is the substring from the end of the string to the position `s.length-shift`, and the second part is the substring from the beginning of the string to the position `s.length-shift`. The function then concatenates the two substrings and returns the result. This is because if the shift value is less than or equal to the length of the string, the circular shift will only shift the string by the specified number of positions. \n\n\n### Racket version\n\n#lang racket\n\n(define (circular_shift x shift)\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (max_fill grid capacity)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_fill))\n    (check-within (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction max_fill(grid, capacity){\n  return grid.reduce((acc, arr) => acc + Math.ceil(arr.reduce((a,b) => a+b)/capacity), 0);\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes in a 2D array of integers and a capacity integer. The function returns the maximum number of times the capacity can be filled in the 2D array.\n\n1. `function max_fill(grid, capacity){` - This line declares a function called `max_fill` that takes in two parameters, `grid` and `capacity`.\n\n2. `return grid.reduce((acc, arr) => acc + Math.ceil(arr.reduce((a,b) => a+b)/capacity), 0);` - This line returns the result of the reduce method applied to the `grid` parameter.\n\n3. `grid.reduce` - This method applies a function to each element of the `grid` array and returns a single value. \n\n4. `(acc, arr) => acc + Math.ceil(arr.reduce((a,b) => a+b)/capacity)` - This is the function that is applied to each element of the `grid` array. It takes in two parameters, `acc` and `arr`. `acc` is the accumulator that stores the result of the previous iteration of the reduce method. `arr` is the current element of the `grid` array that is being processed. \n\n5. `Math.ceil(arr.reduce((a,b) => a+b)/capacity)` - This line calculates the number of times the capacity can be filled in the current element of the `grid` array. It does this by first applying the `reduce` method to the current element of the `grid` array. The `reduce` method takes in a function that adds up all the elements of the current element of the `grid` array. The result of this is then divided by the `capacity` parameter. The `Math.ceil` method is then applied to round up the result to the nearest integer.\n\n6. `, 0);` - This line sets the initial value of the accumulator to 0.\n\n\n### Racket version\n\n#lang racket\n\n(define (max_fill grid capacity)\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (has_close_elements numbers threshold)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate has_close_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction has_close_elements(numbers, threshold){\n  for(let idx in numbers){\n    for(let idx2 in numbers){\n      if(idx != idx2){\n        let distance = Math.abs(numbers[idx] - numbers[idx2]);\n        if(distance < threshold){\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `has_close_elements` that takes in two arguments: `numbers` and `threshold`. The function returns a boolean value indicating whether there are two elements in the `numbers` array that are less than `threshold` apart.\n\nThe function uses a nested for loop to iterate over the `numbers` array and compare each element to every other element in the array. The `idx` variable is used to keep track of the current index being compared, while the `idx2` variable is used to iterate over the rest of the array.\n\nThe `if` statement checks if the current index is not equal to the second index being compared. If they are not equal, the absolute difference between the two elements is calculated using the `Math.abs` function. If the distance between the two elements is less than the `threshold` value, the function returns `true`.\n\nIf the function has iterated over the entire array and has not found two elements that are less than `threshold` apart, the function returns `false`. \n\n\n### Racket version\n\n#lang racket\n\n(define (has_close_elements numbers threshold)\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (numerical_letter_grade grades)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numerical_letter_grade))\n    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list \"A+\" \"B\" \"C-\" \"C\" \"A-\") 0.001)\n    (check-within (candidate (list 1.2)) (list \"D+\") 0.001)\n    (check-within (candidate (list 0.5)) (list \"D-\") 0.001)\n    (check-within (candidate (list 0.0)) (list \"E\") 0.001)\n    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list \"D\" \"D-\" \"C-\" \"B\" \"B+\") 0.001)\n    (check-within (candidate (list 0.0 0.7)) (list \"E\" \"D-\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction numerical_letter_grade(grades){\n  let letter_grade = [];\n  for(let gpa of grades){\n    if(gpa == 4.0){\n      letter_grade.push(\"A+\");\n    }else if(gpa > 3.7){\n      letter_grade.push(\"A\");\n    }else if(gpa > 3.3){\n      letter_grade.push(\"A-\");\n    }else if(gpa > 3.0){\n      letter_grade.push(\"B+\");\n    }else if(gpa > 2.7){\n      letter_grade.push(\"B\");\n    }else if(gpa > 2.3){\n      letter_grade.push(\"B-\");\n    }else if(gpa > 2.0){\n      letter_grade.push(\"C+\");\n    }else if(gpa > 1.7){\n      letter_grade.push(\"C\");\n    }else if(gpa > 1.3){\n      letter_grade.push(\"C-\");\n    }else if(gpa > 1.0){\n      letter_grade.push(\"D+\");\n    }else if(gpa > 0.7){\n      letter_grade.push(\"D\");\n    }else if(gpa > 0.0){\n      letter_grade.push(\"D-\");\n    }else{\n      letter_grade.push(\"E\");\n    }\n  }\n  return letter_grade;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `numerical_letter_grade` that takes in an array of numerical grades and returns an array of letter grades. \n\n```javascript\nfunction numerical_letter_grade(grades){\n```\n\nThe function takes in an array of numerical grades as an argument.\n\n```javascript\nlet letter_grade = [];\n```\n\nThe function initializes an empty array called `letter_grade` to store the letter grades.\n\n```javascript\nfor(let gpa of grades){\n```\n\nThe function loops through each numerical grade in the `grades` array.\n\n```javascript\nif(gpa == 4.0){\n  letter_grade.push(\"A+\");\n}else if(gpa > 3.7){\n  letter_grade.push(\"A\");\n}else if(gpa > 3.3){\n  letter_grade.push(\"A-\");\n}else if(gpa > 3.0){\n  letter_grade.push(\"B+\");\n}else if(gpa > 2.7){\n  letter_grade.push(\"B\");\n}else if(gpa > 2.3){\n  letter_grade.push(\"B-\");\n}else if(gpa > 2.0){\n  letter_grade.push(\"C+\");\n}else if(gpa > 1.7){\n  letter_grade.push(\"C\");\n}else if(gpa > 1.3){\n  letter_grade.push(\"C-\");\n}else if(gpa > 1.0){\n  letter_grade.push(\"D+\");\n}else if(gpa > 0.7){\n  letter_grade.push(\"D\");\n}else if(gpa > 0.0){\n  letter_grade.push(\"D-\");\n}else{\n  letter_grade.push(\"E\");\n}\n```\n\nThe function checks each numerical grade against a set of conditions to determine the corresponding letter grade. If the numerical grade matches a condition, the corresponding letter grade is pushed into the `letter_grade` array.\n\n```javascript\nreturn letter_grade;\n```\n\nThe function returns the `letter_grade` array containing the letter grades. \n\n\n### Racket version\n\n#lang racket\n\n(define (numerical_letter_grade grades)\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (x_or_y n x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate x_or_y))\n    (check-within (candidate 7 34 12) 34 0.001)\n    (check-within (candidate 15 8 5) 5 0.001)\n    (check-within (candidate 3 33 5212) 33 0.001)\n    (check-within (candidate 1259 3 52) 3 0.001)\n    (check-within (candidate 7919 -1 12) -1 0.001)\n    (check-within (candidate 3609 1245 583) 583 0.001)\n    (check-within (candidate 91 56 129) 129 0.001)\n    (check-within (candidate 6 34 1234) 1234 0.001)\n    (check-within (candidate 1 2 0) 0 0.001)\n    (check-within (candidate 2 2 0) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction x_or_y(n, x, y){\n  if (n === 1) return y;\n  for (let i = 2; i < n; i++){\n    if (n % i === 0) return y;\n  }\n  return x;\n}\n\n### Explanation\n\nThe code is an implementation of a function `x_or_y` that takes three arguments: `n`, `x`, and `y`. The function returns `y` if `n` is equal to 1 or if `n` is divisible by any number other than 1 and itself. Otherwise, it returns `x`.\n\nThe function starts with an `if` statement that checks if `n` is equal to 1. If it is, the function immediately returns `y`. Otherwise, the function enters a `for` loop that iterates from 2 to `n - 1`. \n\nInside the loop, the function checks if `n` is divisible by the current value of `i`. If it is, the function immediately returns `y`, indicating that `n` is not a prime number and therefore should return `y`. If the loop completes without finding any factors of `n`, the function returns `x`, indicating that `n` is a prime number and therefore should return `x`. \n\n\n### Racket version\n\n#lang racket\n\n(define (x_or_y n x y)\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (specialFilter nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)\n    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)\n    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)\n    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)\n    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction specialFilter(nums){\n  let count = 0;\n  for(let num of nums){\n    if(num > 10){\n      let odd_digits = [1, 3, 5, 7, 9];\n      let number_as_string = String(num);\n      if(odd_digits.includes(Number(number_as_string[0])) && odd_digits.includes(Number(number_as_string[number_as_string.length-1]))){\n        count++;\n      }\n    }\n  }\n  return count;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `specialFilter` that takes in an array of numbers called `nums`. The function returns the count of numbers in the array that are greater than 10 and have odd digits as their first and last digits.\n\n1. `function specialFilter(nums){`: This line defines the function `specialFilter` that takes in an array of numbers called `nums`.\n2. `let count = 0;`: This line initializes a variable called `count` to 0. This variable will be used to keep track of the count of numbers that meet the criteria.\n3. `for(let num of nums){`: This line starts a loop that iterates over each number in the `nums` array.\n4. `if(num > 10){`: This line checks if the current number is greater than 10.\n5. `let odd_digits = [1, 3, 5, 7, 9];`: This line initializes an array called `odd_digits` that contains the odd digits.\n6. `let number_as_string = String(num);`: This line converts the current number to a string and assigns it to a variable called `number_as_string`.\n7. `if(odd_digits.includes(Number(number_as_string[0])) && odd_digits.includes(Number(number_as_string[number_as_string.length-1]))){`: This line checks if the first and last digits of the current number are odd digits. It does this by converting the first and last characters of the `number_as_string` variable to numbers and checking if they are in the `odd_digits` array.\n8. `count++;`: This line increments the `count` variable if the current number meets the criteria.\n9. `}`: This line ends the if statement.\n10. `}`: This line ends the for loop.\n11. `return count;`: This line returns the `count` variable, which contains the count of numbers that meet the criteria.\n\n\n### Racket version\n\n#lang racket\n\n(define (specialFilter nums)\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (parse_music music_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_music))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"o o o o\") (list 4 4 4 4) 0.001)\n    (check-within (candidate \".| .| .| .|\") (list 1 1 1 1) 0.001)\n    (check-within (candidate \"o| o| .| .| o o o o\") (list 2 2 1 1 4 4 4 4) 0.001)\n    (check-within (candidate \"o| .| o| .| o o| o o|\") (list 2 1 2 1 4 2 4 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction parse_music(music_string){\n  let note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x).map(x => note_map[x]);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `parse_music` that takes a string of music notes as an argument. The function returns an array of integers that represent the notes in the input string. \n\nThe first line of the function defines a dictionary called `note_map` that maps the note symbols to their corresponding integer values. The keys of the dictionary are the note symbols and the values are the corresponding integer values. \n\nThe second line of the function splits the input string into an array of strings using the space character as the delimiter. The `split` method is called on the `music_string` argument and the result is assigned to a variable called `split_music_string`. \n\nThe third line of the function filters the `split_music_string` array to remove any empty strings. The `filter` method is called on the `split_music_string` array and a lambda function is passed as an argument. The lambda function takes a single argument `x` and returns a boolean value. The `filter` method returns a new array that contains only the elements of the original array for which the lambda function returns `true`. In this case, the lambda function returns `true` if `x` is not an empty string. \n\nThe fourth line of the function maps the `split_music_string` array to an array of integers using the `note_map` dictionary. The `map` method is called on the `split_music_string` array and a lambda function is passed as an argument. The lambda function takes a single argument `x` and returns the value of `note_map[x]`. The `map` method returns a new array that contains the result of applying the lambda function to each element of the original array. In this case, the lambda function returns the integer value of the note symbol `x` using the `note_map` dictionary. \n\n\n### Racket version\n\n#lang racket\n\n(define (parse_music music_string)\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (split_words txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_words))\n    (check-within (candidate \"Hello world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello,world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello world,!\") (list \"Hello\" \"world,!\") 0.001)\n    (check-within (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\" \"!\") 0.001)\n    (check-within (candidate \"abcdef\") 3 0.001)\n    (check-within (candidate \"aaabb\") 2 0.001)\n    (check-within (candidate \"aaaBb\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction split_words(txt){\n  if(txt.includes(\" \")){\n    return txt.split(\" \");\n  }else if(txt.includes(\",\")){\n    return txt.replace(/,/g, \" \").split(\" \");\n  }else{\n    return [...txt].filter(i => i.match(/[a-z]/) && i.charCodeAt(0)%2 == 0).length;\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function called `split_words` that takes a string as input. The function returns an array of words if the input string contains spaces, an array of words if the input string contains commas, and the number of even-indexed letters in the input string if it contains neither spaces nor commas.\n\n1. `function split_words(txt){`: This line defines the function `split_words` that takes a string `txt` as input.\n2. `if(txt.includes(\" \")){`: This line checks if the input string contains spaces.\n3. `return txt.split(\" \");`: This line returns an array of words if the input string contains spaces. The `split` method is called on the input string with a space as the delimiter.\n4. `}else if(txt.includes(\",\")){`: This line checks if the input string contains commas.\n5. `return txt.replace(/,/g, \" \").split(\" \");`: This line returns an array of words if the input string contains commas. The `replace` method is called on the input string with a regular expression that matches all commas and replaces them with spaces. The resulting string is then split into an array of words using the `split` method with a space as the delimiter.\n6. `}else{`: This line is executed if the input string contains neither spaces nor commas.\n7. `return [...txt].filter(i => i.match(/[a-z]/) && i.charCodeAt(0)%2 == 0).length;`: This line returns the number of even-indexed letters in the input string. The input string is first converted to an array of characters using the spread operator (`...`). The resulting array is then filtered to include only characters that are lowercase letters (`i.match(/[a-z]/)`) and have an even index (`i.charCodeAt(0)%2 == 0`). The length of the resulting array is returned. \n\n\n### Racket version\n\n#lang racket\n\n(define (split_words txt)\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_distinct_characters string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_distinct_characters))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abcde\") 5 0.001)\n    (check-within (candidate \"abcdecadeCADE\") 5 0.001)\n    (check-within (candidate \"aaaaAAAAaaaa\") 1 0.001)\n    (check-within (candidate \"Jerry jERRY JeRRRY\") 5 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction count_distinct_characters(string){\n  return new Set(string.toLowerCase()).size\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as an argument and returns the number of distinct characters in the string. \n\n1. The function is called `count_distinct_characters` and takes a single argument `string`.\n2. The function returns the size of a new `Set` object created from the string. \n3. The `Set` object is created by passing the string to the `Set` constructor, which returns a new `Set` object containing the unique characters in the string. \n4. The `toLowerCase()` method is called on the string before it is passed to the `Set` constructor to ensure that all characters are in lowercase. \n5. The `size` property of the `Set` object is returned, which gives the number of distinct characters in the string.\n\n\n### Racket version\n\n#lang racket\n\n(define (count_distinct_characters string)\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (bf planet1 planet2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate bf))\n    (check-within (candidate \"Jupiter\" \"Neptune\") (list \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Mercury\") (list \"Venus\") 0.001)\n    (check-within (candidate \"Mercury\" \"Uranus\") (list \"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\") 0.001)\n    (check-within (candidate \"Neptune\" \"Venus\") (list \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Mars\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Jupiter\" \"Makemake\") (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction bf(planet1, planet2){\n  let planet_names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  if(!planet_names.includes(planet1) || !planet_names.includes(planet2) || planet1 == planet2){\n    return [];\n  }\n  let planet1_index = planet_names.indexOf(planet1);\n  let planet2_index = planet_names.indexOf(planet2);\n  if(planet1_index < planet2_index){\n    return planet_names.slice(planet1_index+1, planet2_index);\n  }else{\n    return planet_names.slice(planet2_index+1, planet1_index);\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function `bf` that takes two arguments `planet1` and `planet2`. The function returns an array of planet names that are between `planet1` and `planet2` in the solar system. If `planet1` and `planet2` are not valid planet names or they are the same planet, the function returns an empty array.\n\n1. `let planet_names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];` - initializes an array of planet names in the solar system.\n\n2. `if(!planet_names.includes(planet1) || !planet_names.includes(planet2) || planet1 == planet2){ return []; }` - checks if `planet1` and `planet2` are valid planet names and they are not the same planet. If either of these conditions is not met, the function returns an empty array.\n\n3. `let planet1_index = planet_names.indexOf(planet1);` - gets the index of `planet1` in the `planet_names` array.\n\n4. `let planet2_index = planet_names.indexOf(planet2);` - gets the index of `planet2` in the `planet_names` array.\n\n5. `if(planet1_index < planet2_index){ return planet_names.slice(planet1_index+1, planet2_index); }else{ return planet_names.slice(planet2_index+1, planet1_index); }` - checks if `planet1` comes before `planet2` in the `planet_names` array. If it does, the function returns a slice of the `planet_names` array from the index of `planet1` plus one to the index of `planet2`. If it does not, the function returns a slice of the `planet_names` array from the index of `planet2` plus one to the index of `planet1`. \n\n\n### Racket version\n\n#lang racket\n\n(define (bf planet1 planet2)\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (digitSum s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abAB\") 131 0.001)\n    (check-within (candidate \"abcCd\") 67 0.001)\n    (check-within (candidate \"helloE\") 69 0.001)\n    (check-within (candidate \"woArBld\") 131 0.001)\n    (check-within (candidate \"aAaaaXa\") 153 0.001)\n    (check-within (candidate \" How are yOu?\") 151 0.001)\n    (check-within (candidate \"You arE Very Smart\") 327 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction digitSum(s){\n  if(s === \"\") return 0;\n  return s.split(\"\").reduce((acc, char) => acc + (char.match(/[A-Z]/) ? char.charCodeAt(0) : 0), 0);\n}\n\n### Explanation\n\nThe code is an implementation of a function `digitSum` that takes a string as an argument and returns the sum of the ASCII values of all uppercase letters in the string. If the string is empty, the function returns 0.\n\nThe function first checks if the input string is empty. If it is, the function returns 0. If it is not empty, the function splits the string into an array of characters using the `split` method. The `reduce` method is then called on the resulting array, with an initial value of 0.\n\nThe `reduce` method takes two arguments: a callback function and an initial value. The callback function takes two arguments: an accumulator and the current value of the array being processed. The callback function returns the updated value of the accumulator.\n\nIn this case, the callback function checks if the current character is an uppercase letter using a regular expression (`/[A-Z]/`). If it is, the ASCII value of the character is added to the accumulator using the `charCodeAt` method. If it is not an uppercase letter, 0 is added to the accumulator.\n\nAfter all characters have been processed, the final value of the accumulator is returned as the sum of the ASCII values of all uppercase letters in the input string. \n\n\n### Racket version\n\n#lang racket\n\n(define (digitSum s)\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1 2 3)) 6 0.001)\n    (check-within (candidate (list 1 4 9)) 14 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1)) 9 0.001)\n    (check-within (candidate (list -1 -1 -1 -1 -1 -1 -1 -1 -1)) -3 0.001)\n    (check-within (candidate (list 0)) 0 0.001)\n    (check-within (candidate (list -1 -5 2 -1 -5)) -126 0.001)\n    (check-within (candidate (list -56 -99 1 0 -2)) 3030 0.001)\n    (check-within (candidate (list -1 0 0 0 0 0 0 0 -1)) 0 0.001)\n    (check-within (candidate (list -16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37)) -14196 0.001)\n    (check-within (candidate (list -1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10)) -1448 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sum_squares(lst){\n  let result =[];\n  for(let i =0; i<lst.length; i++){\n    if(i %3 === 0){\n      result.push(lst[i]**2)\n    }else if(i % 4 === 0 && i%3 !== 0){\n      result.push(lst[i]**3)\n    }else{\n      result.push(lst[i])\n    }\n  }\n  return result.reduce((a,b) => a+b,0)\n}\n\n### Explanation\n\nThe code is an implementation of a function named `sum_squares` that takes a list as an input and returns the sum of the squares of some of the elements of the list. \n\nThe function starts by creating an empty array named `result` that will be used to store the squared values of some of the elements of the input list. \n\nIt then enters a `for` loop that iterates over each element of the input list. The loop is controlled by a variable `i` that starts at 0 and increments by 1 until it reaches the length of the input list. \n\nInside the loop, there is an `if` statement that checks if the current value of `i` is divisible by 3 with no remainder. If it is, then the square of the current element is appended to the `result` array using the `push` method. \n\nIf the current value of `i` is not divisible by 3, the code enters an `else if` statement that checks if the current value of `i` is divisible by 4 with no remainder and is not divisible by 3 with no remainder. If it is, then the cube of the current element is appended to the `result` array using the `push` method. \n\nIf neither of the above conditions are met, then the current element is simply appended to the `result` array using the `push` method. \n\nFinally, the function returns the sum of the elements of the `result` array using the `reduce` method. The `reduce` method takes two arguments: a callback function that specifies how to combine the elements of the array, and an initial value of 0. In this case, the callback function is an arrow function that takes two arguments `a` and `b` and returns their sum. The initial value of 0 ensures that the `reduce` method starts with a sum of 0. \n\n\n### Racket version\n\n#lang racket\n\n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_up_to n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_up_to))\n    (check-within (candidate 5) (list 2 3) 0.001)\n    (check-within (candidate 6) (list 2 3 5) 0.001)\n    (check-within (candidate 7) (list 2 3 5) 0.001)\n    (check-within (candidate 10) (list 2 3 5 7) 0.001)\n    (check-within (candidate 0) (list ) 0.001)\n    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)\n    (check-within (candidate 1) (list ) 0.001)\n    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)\n    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)\n    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction count_up_to(n){\n  let primes = [];\n  for(let i=2; i<n; i++){\n    let is_prime = true;\n    for(let j=2; j<i; j++){\n      if(i%j === 0){\n        is_prime = false;\n        break;\n      }\n    }\n    if(is_prime){\n      primes.push(i);\n    }\n  }\n  return primes;\n}\n\n### Explanation\n\nThe code is an implementation of the Sieve of Eratosthenes algorithm to find all prime numbers up to a given number `n`. \n\n1. Declare a function `count_up_to` that takes an integer `n` as an argument.\n2. Declare an empty array `primes` to store the prime numbers found.\n3. Start a `for` loop that initializes a variable `i` to 2, checks if `i` is less than `n`, and increments `i` by 1 after each iteration.\n4. Within the `for` loop, declare a boolean variable `is_prime` and set it to `true`.\n5. Start another `for` loop that initializes a variable `j` to 2, checks if `j` is less than `i`, and increments `j` by 1 after each iteration.\n6. Within the inner `for` loop, check if `i` is divisible by `j` with no remainder. If it is, set `is_prime` to `false` and break out of the inner loop.\n7. After the inner `for` loop, check if `is_prime` is still `true`. If it is, `i` is a prime number, so add it to the `primes` array using the `push` method.\n8. After the outer `for` loop, return the `primes` array.\n\n\n### Racket version\n\n#lang racket\n\n(define (count_up_to n)\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)\n    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)\n    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)\n    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)\n    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)\n    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)\n    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)\n    (check-within (candidate (list 0.0)) 0 0.001)\n    (check-within (candidate (list -1.0)) 1 0.001)\n    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sum_squares(lst){\n  let squared = 0;\n  lst.forEach(i => squared += Math.ceil(i)**2);\n  return squared;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `sum_squares` that takes a list of numbers as an input and returns the sum of the squares of each number in the list. \n\n1. The function is defined with an input parameter `lst`.\n2. A variable `squared` is initialized to 0.\n3. The `forEach` method is called on the input list `lst`. \n4. For each element `i` in `lst`, the `Math.ceil` function is called on `i` and the result is squared using the `**` operator. The squared value is then added to the `squared` variable.\n5. Once all elements in `lst` have been processed, the `squared` variable is returned.\n\n\n### Racket version\n\n#lang racket\n\n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (unique l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique))\n    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction unique(l){\n  return [...new Set(l)].sort((a,b) => a-b);\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns a new list with only the unique numbers sorted in ascending order.\n\n1. The function is defined with the name `unique` and takes a single parameter `l`.\n2. The function returns a new list with only the unique numbers sorted in ascending order.\n3. The `new Set(l)` creates a new set object with the elements of the list `l`. A set is a collection of unique elements, so any duplicate elements in `l` are removed.\n4. The spread operator `...` is used to convert the set back to an array.\n5. The `sort()` method is called on the array to sort the elements in ascending order. The `sort()` method takes a function as an argument that compares two elements and returns a negative, zero, or positive number depending on the order of the elements. In this case, the function `(a,b) => a-b` compares two numbers `a` and `b` and returns a negative number if `a` is less than `b`, zero if `a` is equal to `b`, and a positive number if `a` is greater than `b`. This results in the array being sorted in ascending order.\n6. The sorted array is returned by the function.\n\n\n### Racket version\n\n#lang racket\n\n(define (unique l)\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib))\n    (check-within (candidate 10) 55 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 8) 21 0.001)\n    (check-within (candidate 11) 89 0.001)\n    (check-within (candidate 12) 144 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction fib(n){\n  if(n == 0){\n    return 0;\n  }\n  if(n == 1){\n    return 1;\n  }\n  return fib(n-1) + fib(n-2);\n}\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding numbers. The sequence starts with 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, and so on. \n\nThe function `fib` takes an integer `n` as input and returns the `n`th number in the Fibonacci sequence. \n\nThe first two `if` statements check if `n` is 0 or 1. If `n` is 0, the function returns 0. If `n` is 1, the function returns 1. \n\nIf `n` is not 0 or 1, the function returns the sum of the two preceding numbers in the Fibonacci sequence. This is done by recursively calling the `fib` function with `n-1` and `n-2` as arguments, and adding the results together. \n\n\n### Racket version\n\n#lang racket\n\n(define (fib n)\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fizz_buzz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n    (check-within (candidate 50) 0 0.001)\n    (check-within (candidate 78) 2 0.001)\n    (check-within (candidate 79) 3 0.001)\n    (check-within (candidate 100) 3 0.001)\n    (check-within (candidate 200) 6 0.001)\n    (check-within (candidate 4000) 192 0.001)\n    (check-within (candidate 10000) 639 0.001)\n    (check-within (candidate 100000) 8026 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction fizz_buzz(n){\n  let ns = []\n  for(let i = 0; i < n; i++){\n    if(i % 11 == 0 || i % 13 == 0){\n      ns.push(i)\n    }\n  }\n  let s = ns.join('')\n  let ans = 0\n  for(let c of s){\n    ans += (c == '7')\n  }\n  return ans\n}\n\n### Explanation\n\nThe code is an implementation of the FizzBuzz problem. The function `fizz_buzz` takes an integer `n` as input and returns the number of times the digit `7` appears in the concatenation of all numbers between 0 and `n` (exclusive) that are divisible by 11 or 13.\n\n1. `function fizz_buzz(n){`: This line declares a function called `fizz_buzz` that takes an integer `n` as input.\n2. `let ns = []`: This line declares an empty array called `ns`.\n3. `for(let i = 0; i < n; i++){`: This line starts a loop that iterates over all integers between 0 and `n` (exclusive) and assigns each integer to the variable `i`.\n4. `if(i % 11 == 0 || i % 13 == 0){`: This line checks if `i` is divisible by 11 or 13.\n5. `ns.push(i)`: This line adds `i` to the end of the array `ns` if it is divisible by 11 or 13.\n6. `let s = ns.join('')`: This line concatenates all elements of `ns` into a single string called `s`.\n7. `let ans = 0`: This line declares a variable called `ans` and initializes it to 0.\n8. `for(let c of s){`: This line starts a loop that iterates over all characters in the string `s` and assigns each character to the variable `c`.\n9. `ans += (c == '7')`: This line adds 1 to `ans` if `c` is equal to the character `'7'`.\n10. `return ans`: This line returns the final value of `ans`.\n\n\n### Racket version\n\n#lang racket\n\n(define (fizz_buzz n)\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (Strongest_Extension class_name extensions)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n    (check-within (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\")) \"Watashi.eIGHt8OKe\" 0.001)\n    (check-within (candidate \"Boku123\" (list \"nani\" \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\" 0.001)\n    (check-within (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\" \"123NoooneB321\")) \"__YESIMHERE.NuLl__\" 0.001)\n    (check-within (candidate \"K\" (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\" 0.001)\n    (check-within (candidate \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\" 0.001)\n    (check-within (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"-_-\")) \"YameRore.okIWILL123\" 0.001)\n    (check-within (candidate \"finNNalLLly\" (list \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\" 0.001)\n    (check-within (candidate \"_\" (list \"Bb\" \"91245\")) \"_.Bb\" 0.001)\n    (check-within (candidate \"Sp\" (list \"671235\" \"Bb\")) \"Sp.671235\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction Strongest_Extension(class_name, extensions){\n    let strong = extensions[0];\n    let my_val = extensions[0].replace(/[^A-Z]/g, \"\").length - extensions[0].replace(/[^a-z]/g, \"\").length;\n    for(let s of extensions){\n        let val = s.replace(/[^A-Z]/g, \"\").length - s.replace(/[^a-z]/g, \"\").length;\n        if(val > my_val){\n            strong = s;\n            my_val = val;\n        }\n    }\n    let ans = class_name + \".\" + strong;\n    return ans;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `Strongest_Extension`. The function takes two arguments: `class_name` and `extensions`. `class_name` is a string and `extensions` is an array of strings. The function returns a string that is the concatenation of `class_name` and the string in `extensions` that has the most uppercase letters relative to its lowercase letters.\n\nThe function starts by declaring a variable called `strong` and setting it equal to the first element in the `extensions` array. It then declares a variable called `my_val` and sets it equal to the difference between the number of uppercase letters and lowercase letters in `strong`. This is done using the `replace` method to remove all non-uppercase and non-lowercase letters from `strong` and then taking the difference in length between the original string and the modified string.\n\nThe function then enters a `for` loop that iterates over each element in the `extensions` array. For each element, it calculates the difference between the number of uppercase letters and lowercase letters in the same way as it did for `strong`. If this difference is greater than `my_val`, it sets `strong` equal to the current element and updates `my_val` to the new difference.\n\nFinally, the function concatenates `class_name` and `strong` with a period in between and returns the resulting string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (Strongest_Extension class_name extensions)\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (find_closest_elements numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_closest_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction find_closest_elements(numbers){\n  let closest_pair = null;\n  let distance = null;\n  \n  for(let i=0; i<numbers.length; i++){\n    for(let j=0; j<numbers.length; j++){\n      if(i !== j){\n        let new_distance = Math.abs(numbers[i] - numbers[j]);\n        if(distance === null){\n          distance = new_distance;\n          closest_pair = [numbers[i], numbers[j]].sort((a,b) => a-b);\n        }else if(new_distance < distance){\n          distance = new_distance;\n          closest_pair = [numbers[i], numbers[j]].sort((a,b) => a-b);\n        }\n      }\n    }\n  }\n  \n  return closest_pair;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `find_closest_elements` that takes an array of numbers as an argument and returns an array of the two numbers that have the smallest absolute difference.\n\nThe function first initializes two variables, `closest_pair` and `distance`, to `null`. These variables will be used to keep track of the closest pair of numbers and the distance between them, respectively.\n\nThe function then uses a nested loop to iterate over all possible pairs of numbers in the input array. For each pair of numbers, the function calculates the absolute difference between them using the `Math.abs()` function and stores it in a variable called `new_distance`.\n\nIf `distance` is `null`, the function sets `distance` to `new_distance` and `closest_pair` to the current pair of numbers, sorted in ascending order. If `new_distance` is less than `distance`, the function updates `distance` to `new_distance` and `closest_pair` to the current pair of numbers, sorted in ascending order.\n\nFinally, the function returns `closest_pair`.\n\n\n### Racket version\n\n#lang racket\n\n(define (find_closest_elements numbers)\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (valid_date date)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate valid_date))\n    (check-within (candidate \"03-11-2000\") #t 0.001)\n    (check-within (candidate \"15-01-2012\") #f 0.001)\n    (check-within (candidate \"04-0-2040\") #f 0.001)\n    (check-within (candidate \"06-04-2020\") #t 0.001)\n    (check-within (candidate \"01-01-2007\") #t 0.001)\n    (check-within (candidate \"03-32-2011\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"04-31-3000\") #f 0.001)\n    (check-within (candidate \"06-06-2005\") #t 0.001)\n    (check-within (candidate \"21-31-2000\") #f 0.001)\n    (check-within (candidate \"04-12-2003\") #t 0.001)\n    (check-within (candidate \"04122003\") #f 0.001)\n    (check-within (candidate \"20030412\") #f 0.001)\n    (check-within (candidate \"2003-04\") #f 0.001)\n    (check-within (candidate \"2003-04-12\") #f 0.001)\n    (check-within (candidate \"04-2003\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction valid_date(date){\n  try{\n    date = date.trim()\n    var [month, day, year] = date.split('-').map(Number)\n    if (month < 1 || month > 12) return false\n    if ([1,3,5,7,8,10,12].includes(month) && (day < 1 || day > 31)) return false\n    if ([4,6,9,11].includes(month) && (day < 1 || day > 30)) return false\n    if (month == 2 && (day < 1 || day > 29)) return false\n  } catch {\n    return false\n  }\n  return true\n}\n\n### Explanation\n\nThe code is an implementation of a function called `valid_date` that takes a string as an argument and returns a boolean value indicating whether the string represents a valid date or not.\n\nThe function first tries to trim the input string using the `trim()` method, which removes any whitespace characters from the beginning and end of the string.\n\nNext, the function uses the `split()` method to split the input string into an array of three strings, using the hyphen character as the separator. The `map()` method is then used to convert each string in the array to a number using the `Number()` function. The resulting array of numbers is then destructured into three variables called `month`, `day`, and `year`.\n\nThe function then checks if the `month` variable is less than 1 or greater than 12, which would indicate an invalid month. If this is the case, the function returns `false`.\n\nNext, the function checks if the `month` variable is one of the months with 31 days (January, March, May, July, August, October, or December) and if the `day` variable is less than 1 or greater than 31. If this is the case, the function returns `false`.\n\nThe function then checks if the `month` variable is one of the months with 30 days (April, June, September, or November) and if the `day` variable is less than 1 or greater than 30. If this is the case, the function returns `false`.\n\nFinally, the function checks if the `month` variable is February and if the `day` variable is less than 1 or greater than 29 (since this function assumes a leap year). If this is the case, the function returns `false`.\n\nIf any of the above checks fail, the function catches the error using a `try...catch` block and returns `false`.\n\nIf all of the checks pass, the function returns `true`.\n\n\n### Racket version\n\n#lang racket\n\n(define (valid_date date)\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate 0 1) 1 0.001)\n    (check-within (candidate 1 0) 1 0.001)\n    (check-within (candidate 2 3) 5 0.001)\n    (check-within (candidate 5 7) 12 0.001)\n    (check-within (candidate 7 5) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction add(x, y){\n  return x + y\n}\n\n### Explanation\n\nThe code is an implementation of a function called `add` that takes two arguments `x` and `y`. The function returns the sum of `x` and `y`. \n\n\n### Racket version\n\n#lang racket\n\n(define (add x y)\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triples_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -1)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #t 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 1 2 5 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 9 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -100)) #f 0.001)\n    (check-within (candidate (list 100 3 5 -100)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction triples_sum_to_zero(l){\n  for(let i=0; i<l.length; i++){\n    for(let j=i+1; j<l.length; j++){\n      for(let k=j+1; k<l.length; k++){\n        if(l[i]+l[j]+l[k] === 0){\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `triples_sum_to_zero` that takes an array `l` as an argument. The function returns a boolean value indicating whether there are three elements in the array that sum up to zero.\n\nThe function uses three nested loops to iterate over all possible combinations of three elements in the array. The outer loop iterates over the first element, the second loop iterates over the second element, and the innermost loop iterates over the third element.\n\nThe if statement inside the innermost loop checks whether the sum of the three elements is equal to zero. If it is, the function returns true, indicating that there are three elements in the array that sum up to zero.\n\nIf the function has iterated over all possible combinations of three elements and has not found a sum of zero, it returns false, indicating that there are no three elements in the array that sum up to zero.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (triples_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_divisor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_divisor))\n    (check-within (candidate 3) 1 0.001)\n    (check-within (candidate 7) 1 0.001)\n    (check-within (candidate 10) 5 0.001)\n    (check-within (candidate 100) 50 0.001)\n    (check-within (candidate 49) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction largest_divisor(n){\n  for(let i=n-1; i>=0; i--){\n    if(n%i === 0){\n      return i;\n    }\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes in a number `n` and returns the largest divisor of `n`. \n\n1. `function largest_divisor(n){}` - This is a function declaration that takes in a parameter `n`. \n2. `for(let i=n-1; i>=0; i--)` - This is a for loop that starts from `n-1` and decrements by 1 until `i` is equal to 0. \n3. `if(n%i === 0)` - This is an if statement that checks if `n` is divisible by `i`. \n4. `return i;` - This returns the value of `i` if `n` is divisible by `i`. \n\n\n### Racket version\n\n#lang racket\n\n(define (largest_divisor n)\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_numbers numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"three\") \"three\" 0.001)\n    (check-within (candidate \"three five nine\") \"three five nine\" 0.001)\n    (check-within (candidate \"five zero four seven nine eight\") \"zero four five seven eight nine\" 0.001)\n    (check-within (candidate \"six five four three two one zero\") \"zero one two three four five six\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sort_numbers(numbers){\n  let value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  }\n  return numbers.split(' ').filter(x => x).sort((a,b) => value_map[a] - value_map[b]).join(' ');\n}\n\n### Explanation\n\nThe code is an implementation of a function called `sort_numbers` that takes in a string of space-separated numbers in word form and returns the numbers sorted in ascending order. \n\nThe function first creates an object called `value_map` that maps each number word to its corresponding numerical value. \n\nThe function then splits the input string into an array of words using the `split` method and filters out any empty strings using the `filter` method. \n\nThe filtered array is then sorted using the `sort` method, which takes in a comparison function that compares the numerical values of the words using the `value_map` object. \n\nFinally, the sorted array is joined back into a string using the `join` method and returned. \n\n\n### Racket version\n\n#lang racket\n\n(define (sort_numbers numbers)\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (smallest_change arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallest_change))\n    (check-within (candidate (list 1 2 3 5 4 7 9 6)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 3 2 2)) 1 0.001)\n    (check-within (candidate (list 1 4 2)) 1 0.001)\n    (check-within (candidate (list 1 4 4 2)) 1 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) 0 0.001)\n    (check-within (candidate (list 3 1 1 3)) 0 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction smallest_change(arr){\n  let ans = 0;\n  for(let i=0; i<arr.length/2; i++){\n    if(arr[i] !== arr[arr.length-i-1]){\n      ans++;\n    }\n  }\n  return ans;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `smallest_change` that takes an array of numbers as input and returns the smallest number of changes that need to be made to the array so that it becomes a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\nThe function initializes a variable called `ans` to 0, which will be used to keep track of the number of changes needed to make the array a palindrome.\n\nThe function then loops through the first half of the array using a `for` loop. The loop variable `i` is initialized to 0, and the loop continues as long as `i` is less than the length of the array divided by 2. This is because we only need to check the first half of the array, since the second half is just a mirror image of the first half.\n\nInside the loop, the function checks if the element at index `i` is not equal to the element at the corresponding index in the second half of the array (which is `arr.length-i-1`). If the two elements are not equal, it means that a change needs to be made to one of them so that they become equal. The function increments the `ans` variable by 1 to keep track of the number of changes needed.\n\nAfter the loop has finished, the function returns the value of `ans`, which is the smallest number of changes needed to make the array a palindrome.\n\n\n### Racket version\n\n#lang racket\n\n(define (smallest_change arr)\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (below_threshold l t)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_threshold))\n    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)\n    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction below_threshold(l, t){\n  return l.every(e => e < t);\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments, a list of numbers `l` and a threshold `t`. The function returns a boolean value indicating whether all elements in the list are less than the threshold. \n\nThe function uses the `every` method of the `Array` object to check whether all elements in the list satisfy the condition of being less than the threshold. The `every` method returns `true` if all elements in the array satisfy the condition, and `false` otherwise. \n\nThe function uses an arrow function to define the condition that each element in the list must satisfy. The arrow function takes a single argument `e` and returns the result of the comparison `e < t`. \n\nThe function returns the result of the `every` method call, which is a boolean value indicating whether all elements in the list are less than the threshold. \n\n\n### Racket version\n\n#lang racket\n\n(define (below_threshold l t)\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prod_signs arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-within (candidate (list 1 2 2 -4)) -9 0.001)\n    (check-within (candidate (list 0 1)) 0 0.001)\n    (check-within (candidate (list 1 1 1 2 3 -1 1)) -10 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 2 4 1 2 -1 -1 9)) 20 0.001)\n    (check-within (candidate (list -1 1 -1 1)) 4 0.001)\n    (check-within (candidate (list -1 1 1 1)) -4 0.001)\n    (check-within (candidate (list -1 1 1 0)) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction prod_signs(arr){\n  if(arr.length === 0) return null;\n  let prod = arr.includes(0) ? 0 : (-1) ** arr.filter(x => x < 0).length;\n  return prod * arr.map(Math.abs).reduce((a,b) => a+b);\n}\n\n### Explanation\n\nThe code is an implementation of a function `prod_signs` that takes an array of numbers and returns the product of the signs of the numbers multiplied by the sum of their absolute values. The function first checks if the input array is empty, and if so, returns `null`. If the array is not empty, it calculates the product of the signs of the numbers in the array. If the array contains a zero, the product is zero. Otherwise, the product is -1 raised to the power of the number of negative numbers in the array. The function then calculates the sum of the absolute values of the numbers in the array using the `map` and `reduce` methods, and returns the product of the signs and the sum of the absolute values.\n\nHere is a line-by-line breakdown of the code:\n\n```javascript\nfunction prod_signs(arr){\n```\nThis line defines a function called `prod_signs` that takes an array as its argument.\n\n```javascript\n  if(arr.length === 0) return null;\n```\nThis line checks if the input array is empty, and if so, returns `null`.\n\n```javascript\n  let prod = arr.includes(0) ? 0 : (-1) ** arr.filter(x => x < 0).length;\n```\nThis line calculates the product of the signs of the numbers in the array. If the array contains a zero, the product is zero. Otherwise, the product is -1 raised to the power of the number of negative numbers in the array. The `includes` method is used to check if the array contains a zero, and the `filter` method is used to count the number of negative numbers in the array.\n\n```javascript\n  return prod * arr.map(Math.abs).reduce((a,b) => a+b);\n```\nThis line calculates the sum of the absolute values of the numbers in the array using the `map` and `reduce` methods, and returns the product of the signs and the sum of the absolute values. The `map` method is used to convert each number in the array to its absolute value, and the `reduce` method is used to sum the absolute values. The product of the signs and the sum of the absolute values is returned as the result of the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (prod_signs arr)\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (modp n p)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n    (check-within (candidate 3 5) 3 0.001)\n    (check-within (candidate 1101 101) 2 0.001)\n    (check-within (candidate 0 101) 1 0.001)\n    (check-within (candidate 3 11) 8 0.001)\n    (check-within (candidate 100 101) 1 0.001)\n    (check-within (candidate 30 5) 4 0.001)\n    (check-within (candidate 31 5) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction modp(n, p){\n  let ret = 1;\n  for(let i=0; i<n; i++){\n    ret = (2 * ret) % p;\n  }\n  return ret;\n}\n\n### Explanation\n\nThe code is an implementation of the modular exponentiation algorithm. The function takes two arguments, `n` and `p`, and returns the result of `2^n mod p`. \n\n1. `function modp(n, p){`: This line declares a function named `modp` that takes two arguments, `n` and `p`.\n2. `let ret = 1;`: This line initializes a variable named `ret` to 1. This variable will hold the result of the modular exponentiation.\n3. `for(let i=0; i<n; i++){`: This line starts a loop that will run `n` times. The loop variable is named `i`.\n4. `ret = (2 * ret) % p;`: This line updates the value of `ret` by multiplying it by 2 and taking the result modulo `p`.\n5. `}`: This line ends the loop.\n6. `return ret;`: This line returns the final value of `ret`.\n\n\n### Racket version\n\n#lang racket\n\n(define (modp n p)\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_upper s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n    (check-within (candidate \"aBCdEf\") 1 0.001)\n    (check-within (candidate \"abcdefg\") 0 0.001)\n    (check-within (candidate \"dBBE\") 0 0.001)\n    (check-within (candidate \"B\") 0 0.001)\n    (check-within (candidate \"U\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"EEEE\") 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction count_upper(s){\n  let count = 0;\n  for(let i=0; i<s.length; i+=2){\n    if(\"AEIOU\".includes(s[i])){\n      count++;\n    }\n  }\n  return count;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `count_upper` that takes a string `s` as an argument and returns the number of uppercase vowels in the string. \n\n1. The function starts by initializing a variable `count` to 0.\n2. It then enters a for loop that iterates over the string `s` in steps of 2, starting at the first character (index 0). \n3. For each character in the string that is an uppercase vowel (A, E, I, O, or U), the `count` variable is incremented by 1.\n4. Finally, the function returns the value of `count`.\n\n\n### Racket version\n\n#lang racket\n\n(define (count_upper s)\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (multiply a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate multiply))\n    (check-within (candidate 148 412) 16 0.001)\n    (check-within (candidate 19 28) 72 0.001)\n    (check-within (candidate 2020 1851) 0 0.001)\n    (check-within (candidate 14 -15) 20 0.001)\n    (check-within (candidate 76 67) 42 0.001)\n    (check-within (candidate 17 27) 49 0.001)\n    (check-within (candidate 0 1) 0 0.001)\n    (check-within (candidate 0 0) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction multiply(a, b){\n  return Math.abs(a % 10) * Math.abs(b % 10);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `multiply` that takes two arguments, `a` and `b`. The function returns the product of the last digits of `a` and `b`. \n\nThe `Math.abs` function is used to get the absolute value of the last digit of `a` and `b`. The `%` operator is used to get the remainder of `a` and `b` when divided by 10, which gives the last digit of each number. \n\nThe `*` operator is used to multiply the two last digits together, and the result is returned by the function.\n\n\n### Racket version\n\n#lang racket\n\n(define (multiply a b)\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (unique_digits x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique_digits))\n    (check-within (candidate (list 15 33 1422 1)) (list 1 15 33) 0.001)\n    (check-within (candidate (list 152 323 1422 10)) (list ) 0.001)\n    (check-within (candidate (list 12345 2033 111 151)) (list 111 151) 0.001)\n    (check-within (candidate (list 135 103 31)) (list 31 135) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction unique_digits(x){\n  let odd_digit_elements = [];\n  for(let i of x){\n    if([...String(i)].every(c => parseInt(c) % 2 == 1)){\n      odd_digit_elements.push(i);\n    }\n  }\n  return odd_digit_elements.sort((a,b) => a-b);\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes an array of integers and returns a new array of integers that contain only the integers with odd digits. The returned array is sorted in ascending order.\n\n1. `function unique_digits(x){}`: This is a function declaration that takes an array of integers as an argument. The function is named `unique_digits`.\n\n2. `let odd_digit_elements = [];`: This initializes an empty array called `odd_digit_elements`. This array will be used to store the integers with odd digits.\n\n3. `for(let i of x){}`: This is a for...of loop that iterates over each element `i` in the input array `x`.\n\n4. `if([...String(i)].every(c => parseInt(c) % 2 == 1)){}`: This is an if statement that checks if every digit in the integer `i` is odd. The integer `i` is first converted to a string using `String(i)`, then spread into an array using `[...]`. The `every` method is then called on this array with an arrow function that checks if each digit is odd. If every digit is odd, the arrow function returns `true`, and the `every` method returns `true`. If any digit is even, the arrow function returns `false`, and the `every` method returns `false`. If the `every` method returns `true`, the if statement is true and the code inside the if statement is executed.\n\n5. `odd_digit_elements.push(i);`: This pushes the integer `i` into the `odd_digit_elements` array.\n\n6. `return odd_digit_elements.sort((a,b) => a-b);`: This returns the `odd_digit_elements` array sorted in ascending order using the `sort` method with an arrow function that subtracts `b` from `a`. This sorts the array in ascending order because if `a` is greater than `b`, the result of the subtraction will be positive, and `a` will be placed after `b` in the sorted array. If `a` is less than `b`, the result of the subtraction will be negative, and `a` will be placed before `b` in the sorted array. If `a` is equal to `b`, the result of the subtraction will be 0, and the order of `a` and `b` will not change.\n\n\n### Racket version\n\n#lang racket\n\n(define (unique_digits x)\n"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (will_it_fly q w)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_72_will_it_fly.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate will_it_fly))\n    (check-within (candidate (list 3 2 3) 9) #t 0.001)\n    (check-within (candidate (list 1 2) 5) #f 0.001)\n    (check-within (candidate (list 3) 5) #t 0.001)\n    (check-within (candidate (list 3 2 3) 1) #f 0.001)\n    (check-within (candidate (list 1 2 3) 6) #f 0.001)\n    (check-within (candidate (list 5) 5) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction will_it_fly(q, w){\n  if(q.reduce((a,b) => a+b, 0) > w){\n    return false;\n  }\n  \n  for(let i=0, j=q.length-1; i<j; i++, j--){\n    if(q[i] !== q[j]){\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `will_it_fly` that takes two arguments, `q` and `w`. The function returns a boolean value indicating whether or not it is possible to balance a set of weights `q` on a seesaw, given that the maximum weight the seesaw can hold is `w`.\n\nThe function first checks whether the total weight of the weights in `q` exceeds the maximum weight `w`. If it does, the function returns `false`, indicating that it is not possible to balance the weights on the seesaw.\n\nIf the total weight of the weights in `q` does not exceed the maximum weight `w`, the function then checks whether the weights in `q` are symmetric. It does this by iterating through the weights in `q` from both ends simultaneously, comparing the weights at each end. If the weights are not symmetric, the function returns `false`, indicating that it is not possible to balance the weights on the seesaw.\n\nIf the weights in `q` are both not too heavy and symmetric, the function returns `true`, indicating that it is possible to balance the weights on the seesaw.\n\n\n### Racket version\n\n#lang racket\n\n(define (will_it_fly q w)\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_multiply_prime a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_multiply_prime))\n    (check-within (candidate 5) #f 0.001)\n    (check-within (candidate 30) #t 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #f 0.001)\n    (check-within (candidate 125) #t 0.001)\n    (check-within (candidate 105) #t 0.001)\n    (check-within (candidate 126) #f 0.001)\n    (check-within (candidate 729) #f 0.001)\n    (check-within (candidate 891) #f 0.001)\n    (check-within (candidate 1001) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_multiply_prime(a){\n  function is_prime(n){\n    for(let j=2;j<n;j++){\n      if(n%j==0){\n        return false\n      }\n    }\n    return true\n  }\n  for(let i=2;i<101;i++){\n    if(!is_prime(i)) continue\n    for(let j=2;j<101;j++){\n      if(!is_prime(j)) continue\n      for(let k=2;k<101;k++){\n        if(!is_prime(k)) continue\n        if(i*j*k==a) return true\n      }\n    }\n  }\n  return false\n}\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a number is a product of three prime numbers between 2 and 100. \n\n1. `function is_multiply_prime(a){`: This line defines a function called `is_multiply_prime` that takes a single argument `a`.\n\n2. `function is_prime(n){`: This line defines a nested function called `is_prime` that takes a single argument `n`.\n\n3. `for(let j=2;j<n;j++){`: This line initializes a loop that starts at `j=2` and continues until `j<n`. \n\n4. `if(n%j==0){`: This line checks whether `n` is divisible by `j`.\n\n5. `return false`: This line returns `false` if `n` is divisible by `j`.\n\n6. `return true`: This line returns `true` if `n` is not divisible by any `j` between 2 and `n-1`.\n\n7. `for(let i=2;i<101;i++){`: This line initializes a loop that starts at `i=2` and continues until `i<101`.\n\n8. `if(!is_prime(i)) continue`: This line checks whether `i` is prime. If `i` is not prime, the loop continues to the next iteration.\n\n9. `for(let j=2;j<101;j++){`: This line initializes a loop that starts at `j=2` and continues until `j<101`.\n\n10. `if(!is_prime(j)) continue`: This line checks whether `j` is prime. If `j` is not prime, the loop continues to the next iteration.\n\n11. `for(let k=2;k<101;k++){`: This line initializes a loop that starts at `k=2` and continues until `k<101`.\n\n12. `if(!is_prime(k)) continue`: This line checks whether `k` is prime. If `k` is not prime, the loop continues to the next iteration.\n\n13. `if(i*j*k==a) return true`: This line checks whether the product of `i`, `j`, and `k` is equal to `a`. If it is, the function returns `true`.\n\n14. `return false`: This line returns `false` if no combination of three prime numbers between 2 and 100 multiply to `a`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (is_multiply_prime a)\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (maximum arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)\n    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)\n    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)\n    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)\n    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)\n    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)\n    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)\n    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)\n    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)\n    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)\n    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction maximum(arr, k){\n  if(k === 0){\n    return [];\n  }\n  arr.sort((a,b) => a-b);\n  return arr.slice(-k);\n}\n\n### Explanation\n\nThe code is an implementation of a function that returns the k largest elements in an array. The function takes two arguments, an array and a number k. If k is zero, an empty array is returned. If k is greater than zero, the function sorts the array in ascending order and returns the last k elements of the sorted array.\n\n1. Declare a function called `maximum` that takes two arguments, `arr` and `k`.\n2. If `k` is equal to 0, return an empty array.\n3. Sort the array in ascending order using the `sort` method. The `sort` method takes a callback function that compares two elements of the array and returns a negative number if the first element is less than the second, a positive number if the first element is greater than the second, and 0 if the two elements are equal. In this case, the callback function is an arrow function that subtracts `b` from `a`, resulting in ascending order.\n4. Return the last `k` elements of the sorted array using the `slice` method. The `slice` method takes two arguments, the starting index and the ending index of the slice. In this case, the starting index is `-k`, which means the slice starts from the end of the array and goes backwards `k` elements. The ending index is not specified, which means the slice goes to the end of the array.\n\n\n### Racket version\n\n#lang racket\n\n(define (maximum arr k)\n"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (separate_paren_groups paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_1_separate_paren_groups.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate separate_paren_groups))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list \"(()())\" \"((()))\" \"()\" \"((())()())\") 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list \"()\" \"(())\" \"((()))\" \"(((())))\") 0.001)\n    (check-within (candidate \"(()(())((())))\") (list \"(()(())((())))\") 0.001)\n    (check-within (candidate \"( ) (( )) (( )( ))\") (list \"()\" \"(())\" \"(()())\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction separate_paren_groups(paren_string){\n  let result = [];\n  let current_string = [];\n  let current_depth = 0;\n\n  for(let c of paren_string){\n    if(c === '('){\n      current_depth += 1;\n      current_string.push(c);\n    } else if(c === ')'){\n      current_depth -= 1;\n      current_string.push(c);\n\n      if(current_depth === 0){\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `separate_paren_groups` that takes a string of parentheses and returns an array of strings where each string is a group of parentheses that are at the same depth. Here is a line-by-line explanation of the code:\n\n```javascript\nfunction separate_paren_groups(paren_string){\n```\n\nThis line defines a function called `separate_paren_groups` that takes a single argument called `paren_string`.\n\n```javascript\nlet result = [];\nlet current_string = [];\nlet current_depth = 0;\n```\n\nThese lines define three variables: `result`, `current_string`, and `current_depth`. `result` is an empty array that will eventually hold the groups of parentheses. `current_string` is an empty array that will be used to build up each group of parentheses. `current_depth` is a counter that keeps track of the current depth of the parentheses.\n\n```javascript\nfor(let c of paren_string){\n```\n\nThis line starts a `for` loop that iterates over each character in the `paren_string`.\n\n```javascript\nif(c === '('){\n  current_depth += 1;\n  current_string.push(c);\n} else if(c === ')'){\n  current_depth -= 1;\n  current_string.push(c);\n\n  if(current_depth === 0){\n    result.push(current_string.join(''));\n    current_string = [];\n  }\n}\n```\n\nThese lines are the main logic of the function. If the current character is an open parenthesis (`(`), then we increment the `current_depth` counter and add the character to the `current_string` array. If the current character is a close parenthesis (`)`), then we decrement the `current_depth` counter and add the character to the `current_string` array. If the `current_depth` counter reaches 0, then we know that we have reached the end of a group of parentheses, so we join the `current_string` array into a single string and add it to the `result` array. We also reset the `current_string` array to an empty array so that we can start building up the next group of parentheses.\n\n```javascript\nreturn result;\n```\n\nThis line returns the `result` array, which contains all of the groups of parentheses in the original string.\n\n\n### Racket version\n\n#lang racket\n\n(define (separate_paren_groups paren_string)\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_integers values)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9) 0.001)\n    (check-within (candidate (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction filter_integers(values){\n  return values.filter(x => Number.isInteger(x))\n}\n\n### Explanation\n\nThe code is an implementation of a function called `filter_integers` that takes in an array of values and returns a new array with only the integer values. \n\nThe `filter` method is called on the input array `values`. The `filter` method creates a new array with all elements that pass the test implemented by the provided function. In this case, the provided function is an arrow function that takes in a single argument `x` and returns `true` if `x` is an integer and `false` otherwise. \n\nThe `Number.isInteger` method is used to check if a value is an integer. It returns `true` if the value is an integer and `false` otherwise. \n\nThe `filter` method returns a new array with only the integer values. \n\n\n### Racket version\n\n#lang racket\n\n(define (filter_integers values)\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (skjkasdkd lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate skjkasdkd))\n    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)\n    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)\n    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)\n    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)\n    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)\n    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)\n    (check-within (candidate (list 8191)) 19 0.001)\n    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)\n    (check-within (candidate (list 127 97 8192)) 10 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction skjkasdkd(lst){\n  function isPrime(n){\n    for(let i=2; i<=Math.sqrt(n); i++){\n      if(n%i === 0){\n        return false;\n      }\n    }\n    return true;\n  }\n  let maxx = 0;\n  lst.forEach(i => {\n    if(i > maxx && isPrime(i)){\n      maxx = i;\n    }\n  });\n  return maxx.toString().split('').reduce((a,b) => parseInt(a) + parseInt(b));\n}\n\n### Explanation\n\nThe code is an implementation of a function called `skjkasdkd` that takes a list of integers as input and returns the sum of the digits of the largest prime number in the list. \n\nThe function first defines an inner function called `isPrime` that takes an integer as input and returns a boolean indicating whether the integer is prime or not. The function checks if the input integer is divisible by any integer between 2 and the square root of the input integer. If it is, the function returns false, indicating that the input integer is not prime. If the function completes the loop without finding any divisors, it returns true, indicating that the input integer is prime.\n\nThe function then initializes a variable called `maxx` to 0. It then iterates over each element in the input list using the `forEach` method. For each element, the function checks if it is greater than `maxx` and if it is prime using the `isPrime` function. If both conditions are true, `maxx` is updated to the current element.\n\nFinally, the function converts `maxx` to a string, splits the string into an array of characters, and uses the `reduce` method to sum the digits of the number. The `reduce` method takes a function that takes two arguments, `a` and `b`, and returns their sum. The `reduce` method applies this function to each element of the array, accumulating the sum of the digits. The final result is returned as an integer.\n\n\n### Racket version\n\n#lang racket\n\n(define (skjkasdkd lst)\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (total_match lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate total_match))\n    (check-within (candidate (list ) (list )) (list ) 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\")) (list \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\" \"admin\" \"project\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list \"4\") (list \"1\" \"2\" \"3\" \"4\" \"5\")) (list \"4\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"Hi\")) (list \"hI\" \"Hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hi\")) (list \"hI\" \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hii\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list ) (list \"this\")) (list ) 0.001)\n    (check-within (candidate (list \"this\") (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction total_match(lst1, lst2){\n  let l1 = lst1.reduce((a,b) => a+b.length, 0);\n  let l2 = lst2.reduce((a,b) => a+b.length, 0);\n  \n  return l1 <= l2 ? lst1 : lst2;\n}\n\n### Explanation\n\nThe code is an implementation of a function `total_match` that takes two lists of strings as input and returns the list with the total length of its strings being the smallest. \n\n1. The function takes two arguments `lst1` and `lst2`.\n2. The `reduce` method is called on `lst1` and `lst2` to calculate the total length of their strings. \n3. The `reduce` method takes a callback function that is called on each element of the list. The callback function takes two arguments `a` and `b`. `a` is the accumulated value and `b` is the current value. The callback function returns the sum of the length of the current value `b` and the accumulated value `a`. The initial value of the accumulated value is 0.\n4. The total length of the strings in `lst1` is stored in the variable `l1` and the total length of the strings in `lst2` is stored in the variable `l2`.\n5. The function returns `lst1` if the total length of its strings is less than or equal to the total length of the strings in `lst2`, otherwise it returns `lst2`.\n\n\n### Racket version\n\n#lang racket\n\n(define (total_match lst1 lst2)\n"
  },
  {
    "name": "HumanEval_162_string_to_md5",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_to_md5 text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_162_string_to_md5.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_to_md5))\n    (check-within (candidate \"Hello world\") \"3e25960a79dbc69b674cd4ec67a72c62\" 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"A B C\") \"0ef78513b0cb8cef12743f5aeb35f888\" 0.001)\n    (check-within (candidate \"password\") \"5f4dcc3b5aa765d61d8327deb882cf99\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction string_to_md5(text){\n  const crypto = require('crypto')\n  return text ? crypto.createHash('md5').update(text).digest('hex') : null\n}\n\n### Explanation\n\nThe code is an implementation of a function called `string_to_md5` that takes a string as an argument and returns the md5 hash of the string. \n\n1. The function takes a string as an argument.\n2. The `crypto` module is required to use the `createHash` function.\n3. The `createHash` function is called with the argument `'md5'` to create an instance of the md5 hash function.\n4. The `update` function is called on the hash function instance with the argument `text` to update the hash with the string.\n5. The `digest` function is called on the hash function instance with the argument `'hex'` to return the hash in hexadecimal format.\n6. The result of the hash function is returned if `text` is truthy, otherwise `null` is returned.\n\n\n### Racket version\n\n#lang racket\n\n(define (string_to_md5 text)\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (car_race_collision n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate car_race_collision))\n    (check-within (candidate 2) 4 0.001)\n    (check-within (candidate 3) 9 0.001)\n    (check-within (candidate 4) 16 0.001)\n    (check-within (candidate 8) 64 0.001)\n    (check-within (candidate 10) 100 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction car_race_collision(n){\n  return n*n;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `car_race_collision` that takes in a single parameter `n`. The function returns the result of `n` multiplied by itself. \n\nThe function is very simple and does not have any side effects. It is a pure function that can be easily translated to Racket. \n\n\n### Racket version\n\n#lang racket\n\n(define (car_race_collision n)\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_simple_power x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_simple_power))\n    (check-within (candidate 16 2) #t 0.001)\n    (check-within (candidate 143214 16) #f 0.001)\n    (check-within (candidate 4 2) #t 0.001)\n    (check-within (candidate 9 3) #t 0.001)\n    (check-within (candidate 16 4) #t 0.001)\n    (check-within (candidate 24 2) #f 0.001)\n    (check-within (candidate 128 4) #f 0.001)\n    (check-within (candidate 12 6) #f 0.001)\n    (check-within (candidate 1 1) #t 0.001)\n    (check-within (candidate 1 12) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_simple_power(x, n){\n  if(n == 1){\n    return x == 1;\n  }\n  let power = 1;\n  while(power < x){\n    power *= n;\n  }\n  return power == x;\n}\n\n### Explanation\n\nThe code is an implementation of a function that checks if a number `x` is a power of another number `n`. The function takes two arguments, `x` and `n`.\n\n1. `function is_simple_power(x, n){` - declares a function named `is_simple_power` that takes two arguments, `x` and `n`.\n2. `if(n == 1){` - checks if `n` is equal to 1.\n3. `return x == 1;` - if `n` is equal to 1, returns a boolean indicating if `x` is also equal to 1.\n4. `let power = 1;` - declares a variable named `power` and initializes it to 1.\n5. `while(power < x){` - enters a loop that continues while `power` is less than `x`.\n6. `power *= n;` - multiplies `power` by `n`.\n7. `}` - ends the loop.\n8. `return power == x;` - returns a boolean indicating if `power` is equal to `x`.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_simple_power x n)\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (encode message)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n    (check-within (candidate \"TEST\") \"tgst\" 0.001)\n    (check-within (candidate \"Mudasir\") \"mWDCSKR\" 0.001)\n    (check-within (candidate \"YES\") \"ygs\" 0.001)\n    (check-within (candidate \"This is a message\") \"tHKS KS C MGSSCGG\" 0.001)\n    (check-within (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction encode(message){\n  const vowels = \"aeiouAEIOU\";\n  const vowelsReplace = Object.fromEntries([...vowels].map(v => [v, String.fromCharCode(v.charCodeAt(0) + 2)]));\n  message = message.split('').map(c => vowelsReplace[c] || c).join('');\n  return message.split('').map(c => c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase()).join('');\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a message as input and returns an encoded message. The encoding is done in two steps. \n\nThe first step is to replace all vowels in the message with the letter that comes two letters after it in the alphabet. For example, the letter 'a' is replaced with the letter 'c', the letter 'e' is replaced with the letter 'g', and so on. \n\nThe second step is to convert all uppercase letters in the message to lowercase letters, and all lowercase letters to uppercase letters. \n\nHere is a line-by-line explanation of the code:\n\n```javascript\nfunction encode(message){\n```\nThis line defines a function called `encode` that takes a single parameter called `message`.\n\n```javascript\n  const vowels = \"aeiouAEIOU\";\n```\nThis line defines a constant variable called `vowels` that contains all the vowels in the English alphabet, both uppercase and lowercase.\n\n```javascript\n  const vowelsReplace = Object.fromEntries([...vowels].map(v => [v, String.fromCharCode(v.charCodeAt(0) + 2)]));\n```\nThis line defines a constant variable called `vowelsReplace` that is an object containing key-value pairs. Each key is a vowel from the `vowels` string, and each value is the letter that comes two letters after the corresponding vowel in the alphabet. This is done using the `map` function to iterate over each vowel in the `vowels` string, and the `String.fromCharCode` function to convert the ASCII code of the letter to a string.\n\n```javascript\n  message = message.split('').map(c => vowelsReplace[c] || c).join('');\n```\nThis line replaces all vowels in the `message` string with the corresponding letter from the `vowelsReplace` object. This is done using the `split` function to convert the `message` string into an array of characters, the `map` function to iterate over each character in the array, and the `||` operator to return the original character if it is not a vowel. The resulting array is then converted back into a string using the `join` function.\n\n```javascript\n  return message.split('').map(c => c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase()).join('');\n```\nThis line converts all uppercase letters in the `message` string to lowercase letters, and all lowercase letters to uppercase letters. This is done using the `split` function to convert the `message` string into an array of characters, the `map` function to iterate over each character in the array, and a ternary operator to check if the character is uppercase or lowercase. The resulting array is then converted back into a string using the `join` function.\n\n\n### Racket version\n\n#lang racket\n\n(define (encode message)\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (incr_list l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate incr_list))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)\n    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction incr_list(l){\n  return l.map(e => e+1);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `incr_list` which takes a list `l` as an argument. The function returns a new list, where each element of the input list `l` has been incremented by 1. \n\nThe function uses the `map` method of the input list `l` to create a new list. The `map` method applies a function to each element of the input list and returns a new list with the results. In this case, the function being applied is an arrow function `e => e+1`, which takes an element `e` of the input list and returns the value of `e+1`. \n\nThe function `incr_list` returns the new list created by the `map` method.\n\n\n### Racket version\n\n#lang racket\n\n(define (incr_list l)\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (flip_case string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hello!\") \"hELLO!\" 0.001)\n    (check-within (candidate \"These violent delights have violent ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction flip_case(string){\n  return string.split('').map(c => c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase()).join('');\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as an argument and returns the string with the case of each character flipped. \n\n1. The function is defined with the name `flip_case` and takes a single argument `string`.\n2. The string is split into an array of characters using the `split` method.\n3. The `map` method is called on the array of characters.\n4. For each character `c`, a ternary operator is used to determine whether the character is uppercase or lowercase.\n5. If the character is uppercase, it is converted to lowercase using the `toLowerCase` method.\n6. If the character is lowercase, it is converted to uppercase using the `toUpperCase` method.\n7. The `join` method is called on the resulting array of characters to convert it back into a string.\n8. The resulting string with flipped case is returned.\n\n\n### Racket version\n\n#lang racket\n\n(define (flip_case string)\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (vowels_count s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate vowels_count))\n    (check-within (candidate \"abcde\") 2 0.001)\n    (check-within (candidate \"Alone\") 3 0.001)\n    (check-within (candidate \"key\") 2 0.001)\n    (check-within (candidate \"bye\") 1 0.001)\n    (check-within (candidate \"keY\") 2 0.001)\n    (check-within (candidate \"bYe\") 1 0.001)\n    (check-within (candidate \"ACEDY\") 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction vowels_count(s){\n  let vowels = \"aeiouAEIOU\";\n  let n_vowels = [...s].filter(c => vowels.includes(c)).length;\n  if(s.slice(-1) === 'y' || s.slice(-1) === 'Y'){\n    n_vowels += 1;\n  }\n  return n_vowels;\n}\n\n### Explanation\n\nThe code is an implementation of a function that counts the number of vowels in a string. The function takes a string `s` as input and returns the number of vowels in the string. Here is a line by line explanation of the code:\n\n1. `function vowels_count(s){`: This line defines a function called `vowels_count` that takes a string `s` as input.\n2. `let vowels = \"aeiouAEIOU\";`: This line defines a string variable called `vowels` that contains all the vowels in both uppercase and lowercase.\n3. `let n_vowels = [...s].filter(c => vowels.includes(c)).length;`: This line splits the input string `s` into an array of characters, filters the array to only include vowels, and then returns the length of the filtered array. The `...` syntax is used to spread the string into an array of characters.\n4. `if(s.slice(-1) === 'y' || s.slice(-1) === 'Y'){`: This line checks if the last character of the input string `s` is either 'y' or 'Y'.\n5. `n_vowels += 1;`: This line increments the number of vowels by 1 if the last character of the input string `s` is either 'y' or 'Y'.\n6. `return n_vowels;`: This line returns the number of vowels in the input string `s`.\n\n\n### Racket version\n\n#lang racket\n\n(define (vowels_count s)\n"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sorted_list_sum lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_149_sorted_list_sum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sorted_list_sum))\n    (check-within (candidate (list \"aa\" \"a\" \"aaa\")) (list \"aa\") 0.001)\n    (check-within (candidate (list \"school\" \"AI\" \"asdf\" \"b\")) (list \"AI\" \"asdf\" \"school\") 0.001)\n    (check-within (candidate (list \"d\" \"b\" \"c\" \"a\")) (list ) 0.001)\n    (check-within (candidate (list \"d\" \"dcba\" \"abcd\" \"a\")) (list \"abcd\" \"dcba\") 0.001)\n    (check-within (candidate (list \"AI\" \"ai\" \"au\")) (list \"AI\" \"ai\" \"au\") 0.001)\n    (check-within (candidate (list \"a\" \"b\" \"b\" \"c\" \"c\" \"a\")) (list ) 0.001)\n    (check-within (candidate (list \"aaaa\" \"bbbb\" \"dd\" \"cc\")) (list \"cc\" \"dd\" \"aaaa\" \"bbbb\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sorted_list_sum(lst){\n  lst.sort();\n  let new_lst = [];\n  for(let i of lst){\n    if(i.length%2 === 0){\n      new_lst.push(i);\n    }\n  }\n  return new_lst.sort((a,b) => a.length-b.length);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `sorted_list_sum` that takes a list as an argument and returns a sorted list of even length strings.\n\n1. `function sorted_list_sum(lst){` - Defines a function called `sorted_list_sum` that takes a list as an argument.\n2. `lst.sort();` - Sorts the input list in ascending order.\n3. `let new_lst = [];` - Initializes an empty list called `new_lst`.\n4. `for(let i of lst){` - Loops through each element in the sorted input list.\n5. `if(i.length%2 === 0){` - Checks if the length of the current element is even.\n6. `new_lst.push(i);` - If the length of the current element is even, it is added to the `new_lst` list.\n7. `}` - Closes the if statement.\n8. `return new_lst.sort((a,b) => a.length-b.length);` - Returns the `new_lst` list sorted in ascending order based on the length of each element.\n\n\n### Racket version\n\n#lang racket\n\n(define (sorted_list_sum lst)\n"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (even_odd_palindrome n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_107_even_odd_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_palindrome))\n    (check-within (candidate 123) (list 8 13) 0.001)\n    (check-within (candidate 12) (list 4 6) 0.001)\n    (check-within (candidate 3) (list 1 2) 0.001)\n    (check-within (candidate 63) (list 6 8) 0.001)\n    (check-within (candidate 25) (list 5 6) 0.001)\n    (check-within (candidate 19) (list 4 6) 0.001)\n    (check-within (candidate 9) (list 4 5) 0.001)\n    (check-within (candidate 1) (list 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction even_odd_palindrome(n){\n    function is_palindrome(n){\n        return String(n) == String(n).split(\"\").reverse().join(\"\");\n    }\n    let even_palindrome_count = 0;\n    let odd_palindrome_count = 0;\n    for(let i = 1; i <= n; i++){\n        if(i%2 == 1 && is_palindrome(i)){\n            odd_palindrome_count++;\n        }else if(i%2 == 0 && is_palindrome(i)){\n            even_palindrome_count++;\n        }\n    }\n    return [even_palindrome_count, odd_palindrome_count];\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a number `n` and returns an array of two numbers, the first being the count of even palindromes between 1 and `n`, and the second being the count of odd palindromes between 1 and `n`.\n\nThe function `even_odd_palindrome` takes an argument `n` and defines a nested function `is_palindrome` that takes a number and returns a boolean indicating whether the number is a palindrome or not. The function `is_palindrome` converts the number to a string, splits the string into an array of characters, reverses the array, and joins the array back into a string. If the resulting string is equal to the original string, then the number is a palindrome and the function returns `true`, otherwise it returns `false`.\n\nThe function `even_odd_palindrome` initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops through the numbers from 1 to `n` using a `for` loop. For each number, it checks whether it is odd or even using the modulo operator `%`. If the number is odd and a palindrome, it increments `odd_palindrome_count`. If the number is even and a palindrome, it increments `even_palindrome_count`.\n\nFinally, the function returns an array containing `even_palindrome_count` and `odd_palindrome_count`. \n\n\n### Racket version\n\n#lang racket\n\n(define (even_odd_palindrome n)\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triangle_area a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 3 4 5) 6.0 0.001)\n    (check-within (candidate 1 2 10) -1 0.001)\n    (check-within (candidate 4 8 5) 8.18 0.001)\n    (check-within (candidate 2 2 2) 1.73 0.001)\n    (check-within (candidate 1 2 3) -1 0.001)\n    (check-within (candidate 10 5 7) 16.25 0.001)\n    (check-within (candidate 2 6 3) -1 0.001)\n    (check-within (candidate 1 1 1) 0.43 0.001)\n    (check-within (candidate 2 2 10) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction triangle_area(a, b, c){\n  if(a+b <= c || a+c <= b || b+c <= a){\n    return -1;\n  }\n  let s = (a+b+c)/2;\n  let area = Math.sqrt(s*(s-a)*(s-b)*(s-c));\n  area = Math.round(area*100)/100;\n  return area;\n}\n\n### Explanation\n\nThe code is an implementation of a function that calculates the area of a triangle given the length of its three sides. The function takes three arguments, a, b, and c, which represent the length of the three sides of the triangle.\n\nThe function first checks if the input values are valid for a triangle. If the sum of any two sides is less than or equal to the third side, then the input values do not represent a valid triangle and the function returns -1.\n\nIf the input values are valid, the function calculates the area of the triangle using Heron's formula. Heron's formula is used to calculate the area of a triangle given the length of its three sides. The formula is:\n\narea = sqrt(s(s-a)(s-b)(s-c))\n\nwhere s is the semiperimeter of the triangle, which is half the perimeter of the triangle. The semiperimeter is calculated as:\n\ns = (a+b+c)/2\n\nThe function then rounds the area to two decimal places and returns the result.\n\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a b c)\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (check_dict_case dict)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f 0.001)\n    (check-within (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f 0.001)\n    (check-within (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t 0.001)\n    (check-within (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t 0.001)\n    (check-within (candidate #hash()) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction check_dict_case(dict){\n  if(Object.keys(dict).length == 0){\n    return false;\n  }else{\n    let state = \"start\";\n    for(let key in dict){\n      if(typeof key !== \"string\"){\n        state = \"mixed\";\n        break;\n      }\n      if(state == \"start\"){\n        if(key === key.toUpperCase()){\n          state = \"upper\";\n        }else if(key === key.toLowerCase()){\n          state = \"lower\";\n        }else{\n          break;\n        }\n      }else if((state == \"upper\" && key !== key.toUpperCase()) || (state == \"lower\" && key !== key.toLowerCase())){\n        state = \"mixed\";\n        break;\n      }else{\n        continue;\n      }\n    }\n    return state == \"upper\" || state == \"lower\";\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function `check_dict_case` that takes a dictionary as an argument and returns a boolean value indicating whether the keys of the dictionary are all in the same case (either all uppercase or all lowercase). Here is a line-by-line explanation of the code:\n\n```js\nfunction check_dict_case(dict){\n```\n\nThis line defines a function called `check_dict_case` that takes a single argument `dict`.\n\n```js\nif(Object.keys(dict).length == 0){\n    return false;\n  }else{\n```\n\nThis line checks if the dictionary is empty. If it is, the function returns `false`. Otherwise, the function continues to execute.\n\n```js\nlet state = \"start\";\n```\n\nThis line initializes a variable called `state` to the string `\"start\"`. This variable will be used to keep track of the case of the keys in the dictionary.\n\n```js\nfor(let key in dict){\n```\n\nThis line starts a `for...in` loop that iterates over each key in the dictionary.\n\n```js\nif(typeof key !== \"string\"){\n        state = \"mixed\";\n        break;\n      }\n```\n\nThis line checks if the current key is a string. If it is not, the function sets the `state` variable to `\"mixed\"` and breaks out of the loop.\n\n```js\nif(state == \"start\"){\n        if(key === key.toUpperCase()){\n          state = \"upper\";\n        }else if(key === key.toLowerCase()){\n          state = \"lower\";\n        }else{\n          break;\n        }\n      }\n```\n\nThis block of code is executed if the `state` variable is `\"start\"`. It checks if the current key is all uppercase or all lowercase. If it is, the `state` variable is set to `\"upper\"` or `\"lower\"`, respectively. If the key is neither all uppercase nor all lowercase, the loop is broken.\n\n```js\nelse if((state == \"upper\" && key !== key.toUpperCase()) || (state == \"lower\" && key !== key.toLowerCase())){\n        state = \"mixed\";\n        break;\n      }else{\n        continue;\n      }\n```\n\nThis block of code is executed if the `state` variable is not `\"start\"`. It checks if the current key is the same case as the previous keys. If it is not, the `state` variable is set to `\"mixed\"` and the loop is broken. If the key is the same case as the previous keys, the loop continues.\n\n```js\nreturn state == \"upper\" || state == \"lower\";\n```\n\nThis line returns `true` if the `state` variable is `\"upper\"` or `\"lower\"`, and `false` otherwise.\n\n\n### Racket version\n\n#lang racket\n\n(define (check_dict_case dict)\n"
  },
  {
    "name": "HumanEval_130_tri",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (tri n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_130_tri.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate tri))\n    (check-within (candidate 3) (list 1 3 2 8) 0.001)\n    (check-within (candidate 4) (list 1 3 2 8 3) 0.001)\n    (check-within (candidate 5) (list 1 3 2 8 3 15) 0.001)\n    (check-within (candidate 6) (list 1 3 2 8 3 15 4) 0.001)\n    (check-within (candidate 7) (list 1 3 2 8 3 15 4 24) 0.001)\n    (check-within (candidate 8) (list 1 3 2 8 3 15 4 24 5) 0.001)\n    (check-within (candidate 9) (list 1 3 2 8 3 15 4 24 5 35) 0.001)\n    (check-within (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11) 0.001)\n    (check-within (candidate 0) (list 1) 0.001)\n    (check-within (candidate 1) (list 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction tri(n){\n  if(n === 0){\n    return [1];\n  }\n  let my_tri = [1, 3];\n  for(let i=2; i<n+1; i++){\n    if(i%2 === 0){\n      my_tri.push(i/2+1);\n    }else{\n      my_tri.push(my_tri[i-1]+my_tri[i-2]+(i+3)/2);\n    }\n  }\n  return my_tri;\n}\n\n### Explanation\n\nThe code is an implementation of the [Triangular numbers](https://en.wikipedia.org/wiki/Triangular_number) sequence. The function `tri` takes an integer `n` as input and returns an array of `n` triangular numbers. \n\n1. The function starts by checking if `n` is equal to 0. If it is, it returns an array with a single element, 1. This is the base case of the sequence.\n2. If `n` is not 0, the function initializes an array `my_tri` with the first two elements of the sequence, 1 and 3.\n3. The function then enters a loop that runs `n` times. The loop starts at 2 and ends at `n+1` because the first two elements of the sequence have already been added to `my_tri`.\n4. Inside the loop, the function checks if the current index `i` is even. If it is, the function calculates the triangular number at that index by dividing `i` by 2 and adding 1. This is because every even index in the sequence is equal to the sum of the two previous odd indices.\n5. If `i` is odd, the function calculates the triangular number at that index by adding the previous two elements in the sequence and adding `(i+3)/2`. This is because every odd index in the sequence is equal to the sum of the previous even index and the two previous odd indices.\n6. The function then pushes the calculated triangular number to the `my_tri` array.\n7. After the loop has finished, the function returns the `my_tri` array.\n\n\n### Racket version\n\n#lang racket\n\n(define (tri n)\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (median l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate median))\n    (check-within (candidate (list 3 1 2 4 5)) 3 0.001)\n    (check-within (candidate (list -10 4 6 1000 10 20)) 8.0 0.001)\n    (check-within (candidate (list 5)) 5 0.001)\n    (check-within (candidate (list 6 5)) 5.5 0.001)\n    (check-within (candidate (list 8 1 3 9 9 2 7)) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction median(l){\n  l = l.sort((a,b) => a-b);\n  if(l.length % 2 == 1){\n    return l[Math.floor(l.length/2)];\n  }else{\n    return (l[l.length/2-1] + l[l.length/2])/2;\n  }\n}\n\n### Explanation\n\nThe code is an implementation of the median function in JavaScript. The function takes a list of numbers as input and returns the median of the list. The median is the middle value of a sorted list of numbers. If the list has an even number of elements, the median is the average of the two middle values.\n\nThe function starts by sorting the input list in ascending order. This is done using the `sort` method of the list object. The `sort` method takes a comparison function as input, which is used to determine the order of the elements. In this case, the comparison function is an arrow function that subtracts the second element from the first element (`(a,b) => a-b`). This sorts the list in ascending order.\n\nThe function then checks if the length of the list is odd or even. This is done using the modulo operator (`%`). If the length is odd, the function returns the middle element of the sorted list. This is done using the `floor` method of the `Math` object to round down to the nearest integer (`Math.floor(l.length/2)`). If the length is even, the function returns the average of the two middle elements of the sorted list. This is done by adding the two middle elements and dividing by two (`(l[l.length/2-1] + l[l.length/2])/2`).\n\n\n### Racket version\n\n#lang racket\n\n(define (median l)\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (change_base x base)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n    (check-within (candidate 8 3) \"22\" 0.001)\n    (check-within (candidate 9 3) \"100\" 0.001)\n    (check-within (candidate 234 2) \"11101010\" 0.001)\n    (check-within (candidate 16 2) \"10000\" 0.001)\n    (check-within (candidate 8 2) \"1000\" 0.001)\n    (check-within (candidate 7 2) \"111\" 0.001)\n    (check-within (candidate 2 3) \"2\" 0.001)\n    (check-within (candidate 3 4) \"3\" 0.001)\n    (check-within (candidate 4 5) \"4\" 0.001)\n    (check-within (candidate 5 6) \"5\" 0.001)\n    (check-within (candidate 6 7) \"6\" 0.001)\n    (check-within (candidate 7 8) \"7\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction change_base(x, base){\n  let ret = \"\";\n  while (x > 0){\n    ret = x % base + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `change_base` that takes two arguments `x` and `base`. The function converts a number `x` from base 10 to base `base`. The function returns the converted number as a string.\n\n1. `function change_base(x, base){`: This line defines the function `change_base` that takes two arguments `x` and `base`.\n2. `let ret = \"\";`: This line initializes a variable `ret` to an empty string.\n3. `while (x > 0){`: This line starts a while loop that continues as long as `x` is greater than 0.\n4. `ret = x % base + ret;`: This line calculates the remainder of `x` divided by `base` and concatenates it to the beginning of the `ret` string.\n5. `x = Math.floor(x / base);`: This line updates the value of `x` to be the result of `x` divided by `base`, rounded down to the nearest integer.\n6. `}`: This line ends the while loop.\n7. `return ret;`: This line returns the `ret` string, which contains the converted number in the new base.\n\n\n### Racket version\n\n#lang racket\n\n(define (change_base x base)\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (longest strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"x\" 0.001)\n    (check-within (candidate (list \"x\" \"yyy\" \"zzzz\" \"www\" \"kkkk\" \"abc\")) \"zzzz\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction longest(strings){\n  if(strings.length == 0){\n    return null;\n  }\n  \n  let maxlen = Math.max(...strings.map(x => x.length));\n  for(let s of strings){\n    if(s.length == maxlen){\n      return s;\n    }\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function called `longest` that takes an array of strings as input and returns the longest string in the array. If the input array is empty, the function returns `null`.\n\nThe function first checks if the input array is empty by checking if its length is equal to zero. If it is, the function returns `null`.\n\nIf the input array is not empty, the function calculates the maximum length of the strings in the array using the `Math.max` function and the spread operator (`...`) to pass the array elements as arguments. The result is stored in a variable called `maxlen`.\n\nThe function then iterates over the input array using a `for...of` loop. For each string `s` in the array, the function checks if its length is equal to `maxlen`. If it is, the function returns the string `s`.\n\n\n### Racket version\n\n#lang racket\n\n(define (longest strings)\n"
  },
  {
    "name": "HumanEval_116_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_array arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_116_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-within (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5) 0.001)\n    (check-within (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3) 0.001)\n    (check-within (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77) 0.001)\n    (check-within (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44) 0.001)\n    (check-within (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32) 0.001)\n    (check-within (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sort_array(arr){\n  return arr.sort((a, b) => {\n    return (a.toString(2).match(/1/g) || []).length - (b.toString(2).match(/1/g) || []).length || a - b;\n  });\n}\n\n### Explanation\n\nThe code is an implementation of a function that sorts an array of integers. The sorting is based on two criteria: the number of 1s in the binary representation of the integer, and the integer value itself.\n\nThe function takes an array of integers as input and returns the sorted array.\n\nThe sorting is done using the `sort` method of the array object. The `sort` method takes a function as an argument, which is used to compare the elements of the array.\n\nThe comparison function takes two arguments, `a` and `b`, which are the elements being compared. The function returns a negative value if `a` should come before `b`, a positive value if `a` should come after `b`, and 0 if `a` and `b` are equal.\n\nThe comparison function first calculates the number of 1s in the binary representation of `a` and `b`. This is done by converting the integers to binary strings using the `toString` method with a base of 2, and then using the `match` method with a regular expression to count the number of 1s in the string. If there are no 1s in the string, the `match` method returns `null`, so the `|| []` part of the expression converts `null` to an empty array.\n\nThe comparison function then subtracts the number of 1s in the binary representation of `b` from the number of 1s in the binary representation of `a`. This ensures that integers with fewer 1s in their binary representation come before integers with more 1s.\n\nIf the number of 1s in the binary representation of `a` and `b` is the same, the comparison function subtracts `b` from `a`. This ensures that integers with smaller values come before integers with larger values.\n\nFinally, the `sort` method returns the sorted array.\n\n\n### Racket version\n\n#lang racket\n\n(define (sort_array arr)\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (common l1 l2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n    (check-within (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121)) (list 1 5 653) 0.001)\n    (check-within (candidate (list 5 3 2 8) (list 3 2)) (list 2 3) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction common(l1, l2){\n  let ret = new Set();\n  l1.forEach(e1 => l2.forEach(e2 => {if(e1 === e2){ret.add(e1)}}));\n  return Array.from(ret).sort((a,b) => a-b);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `common` which takes two lists `l1` and `l2` as arguments. The function returns a sorted array of all the elements that appear in both lists.\n\n1. `function common(l1, l2){` - This line declares a function called `common` which takes two arguments `l1` and `l2`.\n2. `let ret = new Set();` - This line declares a new empty set called `ret`.\n3. `l1.forEach(e1 => l2.forEach(e2 => {if(e1 === e2){ret.add(e1)}}));` - This line iterates over each element `e1` in `l1`, and for each element, it iterates over each element `e2` in `l2`. If `e1` is equal to `e2`, then `e1` is added to the `ret` set.\n4. `return Array.from(ret).sort((a,b) => a-b);` - This line converts the `ret` set to an array using `Array.from()`, sorts the array in ascending order using `.sort()`, and returns the sorted array.\n\n\n### Racket version\n\n#lang racket\n\n(define (common l1 l2)\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (cycpattern_check a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate cycpattern_check))\n    (check-within (candidate \"xyzw\" \"xyw\") #f 0.001)\n    (check-within (candidate \"yello\" \"ell\") #t 0.001)\n    (check-within (candidate \"whattup\" \"ptut\") #f 0.001)\n    (check-within (candidate \"efef\" \"fee\") #t 0.001)\n    (check-within (candidate \"abab\" \"aabb\") #f 0.001)\n    (check-within (candidate \"winemtt\" \"tinem\") #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction cycpattern_check(a, b){\n  let l = b.length;\n  let pat = b + b;\n  for(let i=0; i<a.length-l+1; i++){\n    for(let j=0; j<l+1; j++){\n      if(a.slice(i,i+l) === pat.slice(j,j+l)){\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `cycpattern_check` that takes two arguments, `a` and `b`. The function checks if `b` is a cyclic pattern of `a`. A cyclic pattern is a pattern that can be obtained by rotating a string any number of times. For example, \"abcabc\" is a cyclic pattern of \"abc\".\n\nThe function works by first calculating the length of `b` and then creating a new string called `pat` by concatenating `b` with itself. This is done to ensure that all possible cyclic patterns of `b` are included in `pat`.\n\nThe function then uses two nested loops to compare all possible substrings of `a` with `pat`. The outer loop iterates over all possible starting positions of `a` where a substring of length `l` (the length of `b`) can be extracted. The inner loop iterates over all possible starting positions of `pat` where a substring of length `l` can be extracted.\n\nIf the substring of `a` matches the substring of `pat`, then the function returns `true`, indicating that `b` is a cyclic pattern of `a`. If no match is found, the function returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (cycpattern_check a b)\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (minSubArraySum nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minSubArraySum))\n    (check-within (candidate (list 2 3 4 1 2 4)) 1 0.001)\n    (check-within (candidate (list -1 -2 -3)) -6 0.001)\n    (check-within (candidate (list -1 -2 -3 2 -10)) -14 0.001)\n    (check-within (candidate (list -9999999999999999)) -9999999999999999 0.001)\n    (check-within (candidate (list 0 10 20 1000000)) 0 0.001)\n    (check-within (candidate (list -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 100 -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 10 11 13 8 3 4)) 3 0.001)\n    (check-within (candidate (list 100 -33 32 -1 0 -2)) -33 0.001)\n    (check-within (candidate (list -10)) -10 0.001)\n    (check-within (candidate (list 7)) 7 0.001)\n    (check-within (candidate (list 1 -1)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction minSubArraySum(nums){\n  let max_sum = 0\n  let s = 0\n  for (let num of nums){\n    s += -num\n    if (s < 0){\n      s = 0\n    }\n    max_sum = Math.max(s, max_sum)\n  }\n  if (max_sum == 0){\n    max_sum = Math.max(...nums.map(i => -i))\n  }\n  let min_sum = -max_sum\n  return min_sum\n}\n\n### Explanation\n\nThe code is an implementation of the Kadane's algorithm for finding the maximum subarray sum of an array of integers. The function takes an array of integers as input and returns the minimum subarray sum.\n\n1. `function minSubArraySum(nums){` - Defines a function called `minSubArraySum` that takes an array of integers as input.\n\n2. `let max_sum = 0` - Initializes a variable called `max_sum` to 0.\n\n3. `let s = 0` - Initializes a variable called `s` to 0.\n\n4. `for (let num of nums){` - Loops through each element in the input array.\n\n5. `s += -num` - Subtracts the current element from `s` and adds the result to `s`.\n\n6. `if (s < 0){` - Checks if `s` is less than 0.\n\n7. `s = 0` - If `s` is less than 0, sets `s` to 0.\n\n8. `max_sum = Math.max(s, max_sum)` - Sets `max_sum` to the maximum value between `s` and `max_sum`.\n\n9. `}` - Closes the if statement.\n\n10. `if (max_sum == 0){` - Checks if `max_sum` is equal to 0.\n\n11. `max_sum = Math.max(...nums.map(i => -i))` - If `max_sum` is equal to 0, sets `max_sum` to the maximum value between the negation of each element in the input array.\n\n12. `}` - Closes the if statement.\n\n13. `let min_sum = -max_sum` - Initializes a variable called `min_sum` to the negation of `max_sum`.\n\n14. `return min_sum` - Returns `min_sum`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (minSubArraySum nums)\n"
  },
  {
    "name": "HumanEval_88_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_array array)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_88_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5)) (list 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3 4 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0) 0.001)\n    (check-within (candidate (list 2 1)) (list 1 2) 0.001)\n    (check-within (candidate (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87) 0.001)\n    (check-within (candidate (list 21 14 23 11)) (list 23 21 14 11) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sort_array(array){\n  return array.length == 0 ? [] : array.sort((a,b)=>(array[0]+array[array.length-1])%2==0 ? b-a : a-b);\n}\n\n### Explanation\n\nThe code is an implementation of a function that sorts an array of integers in a specific way. The function takes an array as an argument and returns a sorted array. If the input array is empty, the function returns an empty array.\n\nThe sorting algorithm is based on the parity of the sum of the first and last elements of the array. If the sum is even, the array is sorted in descending order. If the sum is odd, the array is sorted in ascending order.\n\nThe function first checks if the input array is empty. If it is, it returns an empty array. If it is not, it sorts the array using the sort() method. The sort() method takes a comparison function as an argument, which determines the order of the elements in the sorted array.\n\nThe comparison function takes two arguments, a and b, which represent two elements of the array. The function calculates the parity of the sum of the first and last elements of the array. If the sum is even, the function returns b-a, which sorts the array in descending order. If the sum is odd, the function returns a-b, which sorts the array in ascending order.\n\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (histogram test)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate histogram))\n    (check-within (candidate \"a b b a\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c a b\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c d g\") #hash((\"a\" .  1) (\"b\" .  1) (\"c\" .  1) (\"d\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"b b b b a\") #hash((\"b\" .  4)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"\") #hash() 0.001)\n    (check-within (candidate \"a\") #hash((\"a\" .  1)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction histogram(test){\n  let dict1 = {};\n  let list1 = test.split(\" \");\n  let t = 0;\n\n  for(let i of list1){\n    if(list1.filter(x => x === i).length > t && i !== ''){\n      t = list1.filter(x => x === i).length;\n    }\n  }\n  if(t > 0){\n    for(let i of list1){\n      if(list1.filter(x => x === i).length === t){\n        dict1[i] = t;\n      }\n    }\n  }\n  return dict1;\n}\n\n### Explanation\n\nThe code is an implementation of a histogram function that takes a string as input and returns a dictionary with the frequency of the most common word(s) in the string.\n\n1. `function histogram(test){`: This line declares a function called `histogram` that takes a string parameter called `test`.\n2. `let dict1 = {};`: This line declares an empty dictionary called `dict1`.\n3. `let list1 = test.split(\" \");`: This line splits the input string `test` into an array of words called `list1`, using the space character as a delimiter.\n4. `let t = 0;`: This line declares a variable called `t` and initializes it to 0.\n5. `for(let i of list1){`: This line starts a loop that iterates over each element `i` in the `list1` array.\n6. `if(list1.filter(x => x === i).length > t && i !== ''){`: This line checks if the frequency of the current element `i` in the `list1` array is greater than the current maximum frequency `t`, and if `i` is not an empty string.\n7. `t = list1.filter(x => x === i).length;`: This line updates the maximum frequency `t` to the frequency of the current element `i` in the `list1` array.\n8. `}`: This line ends the if statement.\n9. `if(t > 0){`: This line checks if the maximum frequency `t` is greater than 0.\n10. `for(let i of list1){`: This line starts a loop that iterates over each element `i` in the `list1` array.\n11. `if(list1.filter(x => x === i).length === t){`: This line checks if the frequency of the current element `i` in the `list1` array is equal to the maximum frequency `t`.\n12. `dict1[i] = t;`: This line adds a key-value pair to the `dict1` dictionary, where the key is the current element `i` and the value is the maximum frequency `t`.\n13. `}`: This line ends the if statement.\n14. `}`: This line ends the for loop.\n15. `return dict1;`: This line returns the `dict1` dictionary with the frequency of the most common word(s) in the input string.\n\n\n### Racket version\n\n#lang racket\n\n(define (histogram test)\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_odd_collatz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_odd_collatz))\n    (check-within (candidate 14) (list 1 5 7 11 13 17) 0.001)\n    (check-within (candidate 5) (list 1 5) 0.001)\n    (check-within (candidate 12) (list 1 3 5) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction get_odd_collatz(n){\n  let odd_collatz = n%2 == 0 ? [] : [n];\n  while(n > 1){\n    if(n%2 == 0){\n      n = n/2;\n    }else{\n      n = n*3 + 1;\n    }\n    if(n%2 == 1){\n      odd_collatz.push(n);\n    }\n  }\n  return odd_collatz.sort((a,b) => a-b);\n}\n\n### Explanation\n\nThe code is an implementation of the Collatz conjecture. The conjecture states that for any positive integer n, the sequence of numbers obtained by repeatedly applying the following function will eventually reach 1:\n\nf(n) = n/2 if n is even\nf(n) = 3n + 1 if n is odd\n\nThe function `get_odd_collatz` takes a single argument `n` and returns an array of the odd numbers in the Collatz sequence starting from `n`. \n\nThe first line of the function initializes an empty array `odd_collatz` if `n` is even, or an array containing `n` if `n` is odd. This is done using a ternary operator that checks if `n%2` is equal to 0.\n\nThe next line starts a while loop that continues until `n` is equal to 1. Inside the loop, the function checks if `n` is even or odd using another ternary operator. If `n` is even, it is divided by 2. If `n` is odd, it is multiplied by 3 and then 1 is added to the result. \n\nThe final if statement checks if `n` is odd. If it is, `n` is added to the `odd_collatz` array using the `push` method.\n\nFinally, the function returns the `odd_collatz` array sorted in ascending order using the `sort` method with a callback function that compares two values and returns a negative number if the first value is less than the second, 0 if they are equal, and a positive number if the first value is greater than the second. \n\n\n### Racket version\n\n#lang racket\n\n(define (get_odd_collatz n)\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (derivative xs)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate derivative))\n    (check-within (candidate (list 3 1 2 4 5)) (list 1 4 12 20) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 6) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 2 2) 0.001)\n    (check-within (candidate (list 3 2 1 0 4)) (list 2 2 0 16) 0.001)\n    (check-within (candidate (list 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction derivative(xs){\n  return xs.map((x, i) => x*i).slice(1);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `derivative` that takes an array of numbers as input. The function returns a new array of numbers that represents the derivative of the input array. \n\nThe derivative of a function is the rate at which the function changes at each point. In this case, the derivative of an array of numbers is the rate at which the values in the array change at each index. \n\nThe function uses the `map` method to create a new array of numbers. The `map` method applies a function to each element of an array and returns a new array with the results. In this case, the function takes two arguments: `x` and `i`. `x` is the value of the current element in the array, and `i` is the index of the current element in the array. The function multiplies `x` by `i` and returns the result. This means that the first element of the new array will be `0`, since `0*0=0`. The second element will be `1*x[1]`, the third element will be `2*x[2]`, and so on. \n\nThe `slice` method is then used to remove the first element of the new array. This is because the first element of the new array represents the derivative of the first element of the input array, which is always `0`. The remaining elements of the new array represent the derivative of the input array at each index. \n\n\n### Racket version\n\n#lang racket\n\n(define (derivative xs)\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fibfib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 1) 0 0.001)\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 24 0.001)\n    (check-within (candidate 10) 81 0.001)\n    (check-within (candidate 12) 274 0.001)\n    (check-within (candidate 14) 927 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction fibfib(n){\n  if(n == 0){\n    return 0;\n  }\n  if(n == 1){\n    return 0;\n  }\n  if(n == 2){\n    return 1;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. The function takes a single argument `n` which is the index of the number in the sequence to be returned. \n\nThe function begins by checking if `n` is equal to 0. If it is, the function returns 0. This is because the first number in the sequence is 0. \n\nThe function then checks if `n` is equal to 1. If it is, the function returns 0. This is because the second number in the sequence is 1. \n\nThe function then checks if `n` is equal to 2. If it is, the function returns 1. This is because the third number in the sequence is 1. \n\nIf `n` is not equal to 0, 1, or 2, the function recursively calls itself three times with `n-1`, `n-2`, and `n-3` as arguments. The results of these recursive calls are added together and returned as the result of the function. This is because the nth number in the sequence is the sum of the three preceding numbers. \n\n\n### Racket version\n\n#lang racket\n\n(define (fibfib n)\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (truncate_number number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n    (check-within (candidate 3.5) 0.5 0.001)\n    (check-within (candidate 1.25) 0.25 0.001)\n    (check-within (candidate 123.0) 0.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction truncate_number(number){\n  return number % 1;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `truncate_number` that takes a single parameter called `number`. The function returns the remainder of the division of `number` by 1. \n\nThe `%` operator in JavaScript is called the modulo operator. It returns the remainder of the division of two numbers. In this case, the number 1 is being divided by `number`. \n\nThe function is a simple way to extract the decimal part of a number. For example, if `number` is 3.14159, the function will return 0.14159. If `number` is 2.0, the function will return 0.0. \n\n\n### Racket version\n\n#lang racket\n\n(define (truncate_number number)\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (max_element l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_element))\n    (check-within (candidate (list 1 2 3)) 3 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction max_element(l){\n  let m = l[0];\n  for(let e of l){\n    if(e > m){\n      m = e;\n    }\n  }\n  return m;\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns the maximum element in the list. Here is a line-by-line explanation of the code:\n\n1. `function max_element(l){`: This line defines a function called `max_element` that takes a list `l` as an argument.\n2. `let m = l[0];`: This line initializes a variable `m` to the first element of the list `l`.\n3. `for(let e of l){`: This line starts a loop that iterates over each element `e` in the list `l`.\n4. `if(e > m){`: This line checks if the current element `e` is greater than the current maximum `m`.\n5. `m = e;`: This line updates the maximum to be the current element if it is greater.\n6. `}`: This line ends the `if` statement.\n7. `}`: This line ends the `for` loop.\n8. `return m;`: This line returns the maximum element `m`.\n\n\n### Racket version\n\n#lang racket\n\n(define (max_element l)\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (closest_integer value)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-within (candidate \"10\") 10 0.001)\n    (check-within (candidate \"14.5\") 15 0.001)\n    (check-within (candidate \"-15.5\") -16 0.001)\n    (check-within (candidate \"15.3\") 15 0.001)\n    (check-within (candidate \"0\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction closest_integer(value){\n  if(value.split('.').length == 2){\n    while(value[value.length-1] == '0'){\n      value = value.slice(0, -1);\n    }\n  }\n  let num = parseFloat(value);\n  if(value.slice(-2) == '.5'){\n    if(num > 0){\n      return Math.ceil(num);\n    }else{\n      return Math.floor(num);\n    }\n  }else if(value.length > 0){\n    return Math.round(num);\n  }else{\n    return 0;\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a string `value` and returns the closest integer to the float value represented by the string. Here is a line by line explanation of the code:\n\n```javascript\nfunction closest_integer(value){\n```\n\nThis line defines a function called `closest_integer` that takes a single argument `value`.\n\n```javascript\n  if(value.split('.').length == 2){\n```\n\nThis line checks if the `value` string contains a decimal point. If it does, the length of the resulting array after splitting the string by the decimal point will be 2.\n\n```javascript\n    while(value[value.length-1] == '0'){\n      value = value.slice(0, -1);\n    }\n```\n\nIf the `value` string contains a decimal point, this block of code removes any trailing zeros from the decimal portion of the string. It does this by repeatedly removing the last character of the string until the last character is not '0'.\n\n```javascript\n  let num = parseFloat(value);\n```\n\nThis line converts the `value` string to a floating point number and assigns it to the variable `num`.\n\n```javascript\n  if(value.slice(-2) == '.5'){\n```\n\nThis line checks if the `value` string ends with the string '.5'. If it does, the number represented by the string is halfway between two integers.\n\n```javascript\n    if(num > 0){\n      return Math.ceil(num);\n    }else{\n      return Math.floor(num);\n    }\n```\n\nIf the number represented by the string is greater than 0, the function returns the smallest integer greater than or equal to the number (i.e. the ceiling of the number). Otherwise, it returns the largest integer less than or equal to the number (i.e. the floor of the number).\n\n```javascript\n  }else if(value.length > 0){\n    return Math.round(num);\n  }else{\n    return 0;\n  }\n```\n\nIf the `value` string does not end with '.5' and has a length greater than 0, the function returns the closest integer to the number represented by the string (i.e. the result of rounding the number). If the `value` string has a length of 0, the function returns 0. This is because an empty string cannot be converted to a number, so it is not possible to determine the closest integer to an empty string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (closest_integer value)\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prime_fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_fib))\n    (check-within (candidate 1) 2 0.001)\n    (check-within (candidate 2) 3 0.001)\n    (check-within (candidate 3) 5 0.001)\n    (check-within (candidate 4) 13 0.001)\n    (check-within (candidate 5) 89 0.001)\n    (check-within (candidate 6) 233 0.001)\n    (check-within (candidate 7) 1597 0.001)\n    (check-within (candidate 8) 28657 0.001)\n    (check-within (candidate 9) 514229 0.001)\n    (check-within (candidate 10) 433494437 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction prime_fib(n){\n  function is_prime(p){\n    if(p < 2){\n      return false;\n    }\n    for(let k=2; k<=Math.min(Math.floor(Math.sqrt(p))+1, p-1); k++){\n      if(p % k === 0){\n        return false;\n      }\n    }\n    return true;\n  }\n  let f = [0, 1];\n  while(true){\n    f.push(f[f.length-1] + f[f.length-2]);\n    if(is_prime(f[f.length-1])){\n      n--;\n    }\n    if(n === 0){\n      return f[f.length-1];\n    }\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function that returns the nth prime Fibonacci number. \n\n```function prime_fib(n){```\nThe function takes in an integer n as an argument.\n\n```function is_prime(p){```\nThe function is_prime takes in an integer p as an argument and returns a boolean value. It checks if p is a prime number by iterating from 2 to the square root of p (inclusive) and checking if p is divisible by any of the numbers in that range.\n\n```if(p < 2){\n      return false;\n    }```\nIf p is less than 2, it is not a prime number and the function returns false.\n\n```for(let k=2; k<=Math.min(Math.floor(Math.sqrt(p))+1, p-1); k++){\n      if(p % k === 0){\n        return false;\n      }\n    }```\nIf p is greater than or equal to 2, the function iterates from 2 to the square root of p (inclusive) and checks if p is divisible by any of the numbers in that range. If p is divisible by any of the numbers in that range, it is not a prime number and the function returns false. If p is not divisible by any of the numbers in that range, it is a prime number and the function returns true.\n\n```let f = [0, 1];```\nThe variable f is initialized as an array with the first two Fibonacci numbers.\n\n```while(true){```\nThe function enters an infinite loop.\n\n```f.push(f[f.length-1] + f[f.length-2]);```\nIn each iteration of the loop, the function calculates the next Fibonacci number by adding the last two numbers in the f array and pushes it to the end of the array.\n\n```if(is_prime(f[f.length-1])){\n      n--;\n    }```\nIf the last number in the f array is a prime number, the function decrements n by 1.\n\n```if(n === 0){\n      return f[f.length-1];\n    }```\nIf n is equal to 0, the function returns the last number in the f array, which is the nth prime Fibonacci number. \n\nThe function keeps iterating until it finds the nth prime Fibonacci number. \n\n\n### Racket version\n\n#lang racket\n\n(define (prime_fib n)\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_product numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_product))\n    (check-within (candidate (list )) (list 0 1) 0.001)\n    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)\n    (check-within (candidate (list 100 0)) (list 100 0) 0.001)\n    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)\n    (check-within (candidate (list 10)) (list 10 10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sum_product(numbers){\n  let sum_value = 0;\n  let prod_value = 1;\n  \n  for(let n of numbers){\n    sum_value += n;\n    prod_value *= n;\n  }\n  \n  return [sum_value, prod_value];\n}\n\n### Explanation\n\nThe code is an implementation of a function called `sum_product` that takes an array of numbers as an argument and returns an array of two values: the sum of the numbers in the array and the product of the numbers in the array.\n\nThe function first initializes two variables `sum_value` and `prod_value` to 0 and 1 respectively.\n\nIt then loops through each number in the input array using a `for...of` loop. For each number, it adds it to `sum_value` and multiplies it with `prod_value`.\n\nFinally, the function returns an array containing `sum_value` and `prod_value`.\n\n\n### Racket version\n\n#lang racket\n\n(define (sum_product numbers)\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (select_words s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n    (check-within (candidate \"Mary had a little lamb\" 4) (list \"little\") 0.001)\n    (check-within (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\") 0.001)\n    (check-within (candidate \"simple white space\" 2) (list ) 0.001)\n    (check-within (candidate \"Hello world\" 4) (list \"world\") 0.001)\n    (check-within (candidate \"Uncle sam\" 3) (list \"Uncle\") 0.001)\n    (check-within (candidate \"\" 4) (list ) 0.001)\n    (check-within (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"f\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction select_words(s, n){\n  let result = [];\n  s.split(\" \").forEach(word => {\n    let n_consonants = 0;\n    for(let i=0; i<word.length; i++){\n      if(![\"a\",\"e\",\"i\",\"o\",\"u\"].includes(word[i].toLowerCase())){\n        n_consonants++;\n      }\n    }\n    if(n_consonants === n){\n      result.push(word);\n    }\n  });\n  return result;\n}\n\n### Explanation\n\nThe code is an implementation of a function `select_words` that takes two arguments: a string `s` and an integer `n`. The function returns an array of words from the input string `s` that have exactly `n` consonants. \n\n1. `let result = [];` initializes an empty array `result` that will be used to store the words that meet the criteria.\n2. `s.split(\" \").forEach(word => {` splits the input string `s` into an array of words and iterates over each word using the `forEach` method.\n3. `let n_consonants = 0;` initializes a counter `n_consonants` to zero. This counter will be used to count the number of consonants in each word.\n4. `for(let i=0; i<word.length; i++){` iterates over each character in the current word using a `for` loop.\n5. `if(![\"a\",\"e\",\"i\",\"o\",\"u\"].includes(word[i].toLowerCase())){` checks if the current character is not a vowel by checking if it is not included in the array `[\"a\",\"e\",\"i\",\"o\",\"u\"]`. The `toLowerCase` method is used to convert the character to lowercase before checking.\n6. `n_consonants++;` increments the `n_consonants` counter if the current character is a consonant.\n7. `if(n_consonants === n){` checks if the number of consonants in the current word is equal to the input integer `n`.\n8. `result.push(word);` adds the current word to the `result` array if it meets the criteria.\n9. `});` closes the `forEach` loop.\n10. `return result;` returns the `result` array containing the words that meet the criteria.\n\n\n### Racket version\n\n#lang racket\n\n(define (select_words s n)\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add_elements arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add_elements))\n    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)\n    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)\n    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)\n    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)\n    (check-within (candidate (list 1) 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction add_elements(arr, k){\n  return arr.slice(0,k).reduce((a,b) => (String(b).length <= 2) ? a+b : a, 0);\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes an array and a number k as arguments. The function returns the sum of the first k elements of the array that have a length of 2 or less. \n\nThe function first slices the array to get the first k elements. It then uses the reduce method to sum the elements that have a length of 2 or less. The reduce method takes two arguments, a callback function and an initial value. The callback function takes two arguments, an accumulator and a current value. The function checks if the length of the current value is less than or equal to 2. If it is, it adds the current value to the accumulator. If it is not, it returns the accumulator without adding the current value. The initial value of the accumulator is 0. \n\n\n### Racket version\n\n#lang racket\n\n(define (add_elements arr k)\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (eat number need remaining)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate eat))\n    (check-within (candidate 5 6 10) (list 11 4) 0.001)\n    (check-within (candidate 4 8 9) (list 12 1) 0.001)\n    (check-within (candidate 1 10 10) (list 11 0) 0.001)\n    (check-within (candidate 2 11 5) (list 7 0) 0.001)\n    (check-within (candidate 4 5 7) (list 9 2) 0.001)\n    (check-within (candidate 4 5 1) (list 5 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction eat(number, need, remaining){\n  if(need <= remaining){\n    return [number + need, remaining-need];\n  }else{\n    return [number + remaining, 0];\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function called `eat` that takes three arguments: `number`, `need`, and `remaining`. The function returns an array of two elements: the first element is the sum of `number` and `need` if `need` is less than or equal to `remaining`, otherwise it is the sum of `number` and `remaining`. The second element is the difference between `remaining` and `need` if `need` is less than or equal to `remaining`, otherwise it is 0.\n\nThe function first checks if `need` is less than or equal to `remaining` using an if statement. If it is, it returns an array containing the sum of `number` and `need` as the first element, and the difference between `remaining` and `need` as the second element. If `need` is greater than `remaining`, the function returns an array containing the sum of `number` and `remaining` as the first element, and 0 as the second element. \n\n\n### Racket version\n\n#lang racket\n\n(define (eat number need remaining)\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (odd_count lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate odd_count))\n    (check-within (candidate (list \"1234567\")) (list \"the number of odd elements 4n the str4ng 4 of the 4nput.\") 0.001)\n    (check-within (candidate (list \"3\" \"11111111\")) (list \"the number of odd elements 1n the str1ng 1 of the 1nput.\" \"the number of odd elements 8n the str8ng 8 of the 8nput.\") 0.001)\n    (check-within (candidate (list \"271\" \"137\" \"314\")) (list \"the number of odd elements 2n the str2ng 2 of the 2nput.\" \"the number of odd elements 3n the str3ng 3 of the 3nput.\" \"the number of odd elements 2n the str2ng 2 of the 2nput.\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction odd_count(lst){\n  let res = [];\n  for(let arr of lst){\n    let n = arr.split(\"\").filter(d => parseInt(d)%2 === 1).length;\n    res.push(\"the number of odd elements \" + n + \"n the str\"+ n +\"ng \"+ n +\" of the \"+ n +\"nput.\");\n  }\n  return res;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `odd_count` that takes in a list of strings and returns a list of strings. The function counts the number of odd digits in each string and returns a string that includes the count and the length of the string. \n\n1. `function odd_count(lst){}` - This line defines a function called `odd_count` that takes in a list of strings as an argument.\n\n2. `let res = [];` - This line initializes an empty array called `res` that will be used to store the results of the function.\n\n3. `for(let arr of lst){}` - This line starts a for loop that iterates over each string in the input list.\n\n4. `let n = arr.split(\"\").filter(d => parseInt(d)%2 === 1).length;` - This line splits the current string into an array of characters, filters out the even digits, and counts the number of odd digits. The result is stored in a variable called `n`.\n\n5. `res.push(\"the number of odd elements \" + n + \"n the str\"+ n +\"ng \"+ n +\" of the \"+ n +\"nput.\");` - This line creates a string that includes the count of odd digits and the length of the input string. The string is then added to the `res` array.\n\n6. `return res;` - This line returns the `res` array, which contains the results of the function.\n\n\n### Racket version\n\n#lang racket\n\n(define (odd_count lst)\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (next_smallest lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)\n    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list -35 34 12 -45)) -35 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction next_smallest(lst){\n  lst = [...new Set(lst)].sort((a,b) => a-b);\n  return lst.length < 2 ? null : lst[1];\n}\n\n### Explanation\n\nThe code is an implementation of a function called `next_smallest` that takes a list of numbers as an argument. The function returns the second smallest number in the list. If the list has only one unique number, the function returns null.\n\nThe first line of the function creates a new list by removing duplicates from the input list. The `new Set(lst)` creates a new set object from the input list, which automatically removes duplicates. The `...` syntax is the spread operator, which is used to spread the elements of the set into a new array. The resulting array is then sorted in ascending order using the `sort()` method. The `sort()` method takes a function as an argument that compares two elements of the array and returns a negative number if the first element is smaller, a positive number if the first element is larger, and zero if they are equal. In this case, the function `(a,b) => a-b` subtracts the second element from the first element, which sorts the array in ascending order.\n\nThe second line of the function checks if the length of the sorted list is less than 2. If it is, the function returns null. If it is not, the function returns the second element of the sorted list, which is the second smallest number in the original list.\n\n\n### Racket version\n\n#lang racket\n\n(define (next_smallest lst)\n"
  },
  {
    "name": "HumanEval_87_get_row",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_row lst x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_87_get_row.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_row))\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 4) (list 1 0) (list 2 5) (list 2 0)) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6)) 2) (list (list 0 1) (list 1 1) (list 2 1) (list 3 1) (list 4 1) (list 5 1)) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 1 3 4 5 6) (list 1 2 1 4 5 6) (list 1 2 3 1 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 0) (list 2 1) (list 2 0) (list 3 2) (list 3 0) (list 4 3) (list 4 0) (list 5 4) (list 5 0) (list 6 5) (list 6 0)) 0.001)\n    (check-within (candidate (list ) 1) (list ) 0.001)\n    (check-within (candidate (list (list 1)) 2) (list ) 0.001)\n    (check-within (candidate (list (list ) (list 1) (list 1 2 3)) 3) (list (list 2 2)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction get_row(lst, x){\n  let coords = [];\n  for(let i=0; i<lst.length; i++){\n    for(let j=0; j<lst[i].length; j++){\n      if(lst[i][j] === x){\n        coords.push([i,j]);\n      }\n    }\n  }\n  return coords.sort((a,b) => a[0] - b[0] || b[1] - a[1]);\n}\n\n### Explanation\n\nThe code is an implementation of a function `get_row` that takes two arguments, a list of lists `lst` and a value `x`. The function returns a list of coordinates of the value `x` in the list of lists `lst`. \n\n1. `function get_row(lst, x){}` - defines a function `get_row` that takes two arguments, a list of lists `lst` and a value `x`.\n2. `let coords = [];` - initializes an empty list `coords` to store the coordinates of the value `x`.\n3. `for(let i=0; i<lst.length; i++){}` - loops through each list in `lst`.\n4. `for(let j=0; j<lst[i].length; j++){}` - loops through each element in the current list.\n5. `if(lst[i][j] === x){}` - checks if the current element is equal to the value `x`.\n6. `coords.push([i,j]);` - if the current element is equal to the value `x`, adds the coordinates of the element to the list `coords`.\n7. `return coords.sort((a,b) => a[0] - b[0] || b[1] - a[1]);` - returns the list of coordinates sorted first by the first element of each coordinate in ascending order, then by the second element of each coordinate in descending order.\n\n\n### Racket version\n\n#lang racket\n\n(define (get_row lst x)\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_by_prefix strings prefix)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction filter_by_prefix(strings, prefix){\n  return strings.filter(x => x.startsWith(prefix))\n}\n\n### Explanation\n\nThe code is an implementation of a function called `filter_by_prefix` that takes in two arguments: `strings` and `prefix`. The function returns a new array of strings that start with the `prefix` argument.\n\nThe `filter` method is called on the `strings` array, which returns a new array containing all the elements of the original array that pass a certain test. The test is defined by the function passed to the `filter` method as an argument. In this case, the function is an arrow function that takes in a single argument `x` and returns a boolean value indicating whether `x` starts with the `prefix` argument.\n\nThe `startsWith` method is called on the `x` argument, which returns a boolean value indicating whether the string starts with the specified prefix.\n\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_prefix strings prefix)\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (choose_num x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n    (check-within (candidate 12 15) 14 0.001)\n    (check-within (candidate 13 12) -1 0.001)\n    (check-within (candidate 33 12354) 12354 0.001)\n    (check-within (candidate 5234 5233) -1 0.001)\n    (check-within (candidate 6 29) 28 0.001)\n    (check-within (candidate 27 10) -1 0.001)\n    (check-within (candidate 7 7) -1 0.001)\n    (check-within (candidate 546 546) 546 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction choose_num(x, y){\n  if(x > y){\n    return -1;\n  }\n  if(y % 2 === 0){\n    return y;\n  }\n  if(x === y){\n    return -1;\n  }\n  return y - 1;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `choose_num` that takes two arguments `x` and `y`. \n\nThe function first checks if `x` is greater than `y`. If it is, the function returns `-1`. \n\nIf `x` is not greater than `y`, the function checks if `y` is an even number. If it is, the function returns `y`.\n\nIf `y` is not even, the function checks if `x` is equal to `y`. If it is, the function returns `-1`.\n\nIf `x` is not greater than `y`, `y` is not even, and `x` is not equal to `y`, the function returns `y - 1`.\n\n\n### Racket version\n\n#lang racket\n\n(define (choose_num x y)\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prime_length string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n    (check-within (candidate \"Hello\") #t 0.001)\n    (check-within (candidate \"abcdcba\") #t 0.001)\n    (check-within (candidate \"kittens\") #t 0.001)\n    (check-within (candidate \"orange\") #f 0.001)\n    (check-within (candidate \"wow\") #t 0.001)\n    (check-within (candidate \"world\") #t 0.001)\n    (check-within (candidate \"MadaM\") #t 0.001)\n    (check-within (candidate \"Wow\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"HI\") #t 0.001)\n    (check-within (candidate \"go\") #t 0.001)\n    (check-within (candidate \"gogo\") #f 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaa\") #f 0.001)\n    (check-within (candidate \"Madam\") #t 0.001)\n    (check-within (candidate \"M\") #f 0.001)\n    (check-within (candidate \"0\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction prime_length(string){\n  let l = string.length;\n  if(l == 0 || l == 1){\n    return false;\n  }\n  for(let i=2; i<l; i++){\n    if(l % i == 0){\n      return false;\n    }\n  }\n  return true;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `prime_length` that takes a string as an argument and returns a boolean value. The function checks if the length of the string is a prime number. If the length is a prime number, the function returns `true`, otherwise it returns `false`.\n\n1. `function prime_length(string){` - This line declares a function called `prime_length` that takes a string as an argument.\n2. `let l = string.length;` - This line declares a variable called `l` and assigns it the value of the length of the string.\n3. `if(l == 0 || l == 1){` - This line checks if the length of the string is equal to 0 or 1. If it is, the function returns `false`.\n4. `for(let i=2; i<l; i++){` - This line starts a `for` loop that iterates from 2 to the length of the string.\n5. `if(l % i == 0){` - This line checks if the length of the string is divisible by the current value of `i`. If it is, the function returns `false`.\n6. `return true;` - This line is executed if the length of the string is a prime number. It returns `true`.\n\n\n### Racket version\n\n#lang racket\n\n(define (prime_length string)\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_to_n n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_to_n))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 6) 21 0.001)\n    (check-within (candidate 11) 66 0.001)\n    (check-within (candidate 30) 465 0.001)\n    (check-within (candidate 100) 5050 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sum_to_n(n){\n  return n*(n+1)/2;\n}\n\n### Explanation\n\nThe code is an implementation of the arithmetic series formula. The formula is used to calculate the sum of a sequence of numbers. The formula is:\n\nsum = n*(n+1)/2\n\nwhere n is the number of terms in the sequence.\n\nThe function `sum_to_n` takes a single argument `n` which is the number of terms in the sequence. The function returns the sum of the sequence.\n\nThe function calculates the sum of the sequence using the arithmetic series formula. The formula is:\n\nsum = n*(n+1)/2\n\nThe function returns the value of the sum.\n\n\n### Racket version\n\n#lang racket\n\n(define (sum_to_n n)\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fix_spaces text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fix_spaces))\n    (check-within (candidate \"Example\") \"Example\" 0.001)\n    (check-within (candidate \"Mudasir Hanif \") \"Mudasir_Hanif_\" 0.001)\n    (check-within (candidate \"Yellow Yellow  Dirty  Fellow\") \"Yellow_Yellow__Dirty__Fellow\" 0.001)\n    (check-within (candidate \"Exa   mple\") \"Exa-mple\" 0.001)\n    (check-within (candidate \"   Exa 1 2 2 mple\") \"-Exa_1_2_2_mple\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction fix_spaces(text){\n  let new_text = \"\";\n  let i = 0;\n  let start = 0, end = 0;\n  while(i < text.length){\n    if(text[i] === \" \"){\n      end += 1;\n    }else{\n      if(end - start > 2){\n        new_text += \"-\"+text[i];\n      }else if(end - start > 0){\n        new_text += \"_\".repeat(end - start)+text[i];\n      }else{\n        new_text += text[i];\n      }\n      start = i+1;\n      end = i+1;\n    }\n    i+=1;\n  }\n  if(end - start > 2){\n    new_text += \"-\";\n  }else if(end - start > 0){\n    new_text += \"_\".repeat(end - start);\n  }\n  return new_text;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `fix_spaces` that takes in a string `text` and returns a new string with spaces replaced by underscores or hyphens depending on the number of spaces in a row. The function works as follows:\n\n1. Initialize a new empty string `new_text` to hold the new text.\n2. Initialize a variable `i` to 0 to keep track of the current position in the input string.\n3. Initialize variables `start` and `end` to 0 to keep track of the start and end positions of consecutive spaces.\n4. Loop through the input string using a `while` loop until `i` is equal to the length of the string.\n5. If the current character at position `i` is a space, increment `end` by 1 to keep track of the number of consecutive spaces.\n6. If the current character at position `i` is not a space, then:\n   1. If the number of spaces between `start` and `end` is greater than 2, add a hyphen followed by the current character to `new_text`.\n   2. If the number of spaces between `start` and `end` is greater than 0 but less than or equal to 2, add underscores equal to the number of spaces between `start` and `end`, followed by the current character to `new_text`.\n   3. If there are no spaces between `start` and `end`, simply add the current character to `new_text`.\n   4. Set `start` and `end` to `i+1` to start counting spaces again.\n7. Increment `i` by 1 to move to the next character in the input string.\n8. After the loop, check if there are any remaining spaces between `start` and `end` and add underscores or a hyphen as appropriate.\n9. Return the new string `new_text`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (fix_spaces text)\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (rolling_max numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)\n    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction rolling_max(numbers){\n  let running_max = null;\n  let result = [];\n\n  for(let n of numbers){\n    if(running_max === null){\n      running_max = n;\n    } else {\n      running_max = Math.max(running_max, n);\n    }\n    result.push(running_max);\n  }\n  return result;\n}\n\n### Explanation\n\nThe code is an implementation of a rolling maximum function. The function takes an array of numbers as input and returns an array of the same length, where each element is the maximum value of the original array up to that index.\n\nThe function starts by initializing two variables: `running_max` and `result`. `running_max` is used to keep track of the maximum value seen so far, and `result` is the array that will be returned.\n\nThe function then iterates over each element of the input array using a for-of loop. For each element, it checks if `running_max` is null. If it is, it sets `running_max` to the current element. Otherwise, it uses the `Math.max` function to compare `running_max` with the current element and update `running_max` to the larger of the two.\n\nFinally, the function pushes the current value of `running_max` onto the `result` array and continues to the next element of the input array. Once all elements have been processed, the function returns the `result` array.\n\n\n### Racket version\n\n#lang racket\n\n(define (rolling_max numbers)\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (words_in_sentence sentence)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_in_sentence))\n    (check-within (candidate \"This is a test\") \"is\" 0.001)\n    (check-within (candidate \"lets go for swimming\") \"go for\" 0.001)\n    (check-within (candidate \"there is no place available here\") \"there is no place\" 0.001)\n    (check-within (candidate \"Hi I am Hussein\") \"Hi am Hussein\" 0.001)\n    (check-within (candidate \"go for it\") \"go for it\" 0.001)\n    (check-within (candidate \"here\") \"\" 0.001)\n    (check-within (candidate \"here is\") \"is\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction words_in_sentence(sentence){\n  let new_lst = [];\n  for(let word of sentence.split(\" \")){\n    let flg = 0;\n    if(word.length == 1){\n      flg = 1;\n    }\n    for(let i=2; i<word.length; i++){\n      if(word.length%i == 0){\n        flg = 1;\n      }\n    }\n    if(flg == 0 || word.length == 2){\n      new_lst.push(word);\n    }\n  }\n  return new_lst.join(\" \");\n}\n\n### Explanation\n\nThe code is an implementation of a function called `words_in_sentence` that takes a string argument called `sentence`. The function returns a string of words from the input sentence that are not divisible by any number other than 1 and themselves. \n\n1. `let new_lst = [];` creates an empty list called `new_lst` that will be used to store the words that meet the criteria.\n2. `for(let word of sentence.split(\" \")){` splits the input sentence into words using the space character as a delimiter and loops over each word.\n3. `let flg = 0;` creates a variable called `flg` and sets it to 0. This variable will be used to keep track of whether or not a word meets the criteria.\n4. `if(word.length == 1){` checks if the length of the current word is 1. If it is, then the word is automatically added to the `new_lst` list because it is not divisible by any number other than 1 and itself.\n5. `flg = 1;` sets the `flg` variable to 1 if the length of the current word is 1. This is done to ensure that the word is added to the `new_lst` list.\n6. `for(let i=2; i<word.length; i++){` loops over each number from 2 to the length of the current word minus 1.\n7. `if(word.length%i == 0){` checks if the length of the current word is divisible by the current number in the loop. If it is, then the `flg` variable is set to 1 because the word is not prime.\n8. `if(flg == 0 || word.length == 2){` checks if the `flg` variable is 0 or if the length of the current word is 2. If either of these conditions are true, then the current word is added to the `new_lst` list because it is not divisible by any number other than 1 and itself.\n9. `new_lst.push(word);` adds the current word to the `new_lst` list if it meets the criteria.\n10. `return new_lst.join(\" \");` returns a string of the words in the `new_lst` list joined together with a space character as a delimiter.\n\n\n### Racket version\n\n#lang racket\n\n(define (words_in_sentence sentence)\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_closest_vowel word)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-within (candidate \"yogurt\") \"u\" 0.001)\n    (check-within (candidate \"full\") \"u\" 0.001)\n    (check-within (candidate \"easy\") \"\" 0.001)\n    (check-within (candidate \"eAsy\") \"\" 0.001)\n    (check-within (candidate \"ali\") \"\" 0.001)\n    (check-within (candidate \"bad\") \"a\" 0.001)\n    (check-within (candidate \"most\") \"o\" 0.001)\n    (check-within (candidate \"ab\") \"\" 0.001)\n    (check-within (candidate \"ba\") \"\" 0.001)\n    (check-within (candidate \"quick\") \"\" 0.001)\n    (check-within (candidate \"anime\") \"i\" 0.001)\n    (check-within (candidate \"Asia\") \"\" 0.001)\n    (check-within (candidate \"Above\") \"o\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction get_closest_vowel(word){\n  let vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n  if(word.length < 3){\n    return \"\";\n  }\n  for(let i=word.length-2; i>0; i--){\n    if(vowels.has(word[i])){\n      if(!vowels.has(word[i-1]) && !vowels.has(word[i+1])){\n        return word[i];\n      }\n    }\n  }\n  return \"\";\n}\n\n### Explanation\n\nThe code is an implementation of a function called `get_closest_vowel` that takes a string argument called `word`. The function returns a string that is the closest vowel to the middle of the word. If the word is less than 3 characters long, the function returns an empty string.\n\nThe function starts by creating a new `Set` object called `vowels` that contains all the vowels in both uppercase and lowercase. \n\nIf the length of the `word` argument is less than 3, the function returns an empty string.\n\nThe function then enters a `for` loop that starts at the second to last character of the `word` argument and iterates backwards until it reaches the second character. \n\nWithin the loop, the function checks if the current character is a vowel by using the `has` method of the `vowels` set. If the current character is a vowel, the function checks if the characters immediately before and after the current character are not vowels. If both conditions are true, the function returns the current character.\n\nIf the loop completes without finding a suitable vowel, the function returns an empty string. \n\n\n### Racket version\n\n#lang racket\n\n(define (get_closest_vowel word)\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (compare game guess)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare))\n    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)\n    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction compare(game, guess){\n  return game.map((x,i) => Math.abs(x-guess[i]));\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes two arrays as input, `game` and `guess`, and returns an array of the absolute difference between the elements of the two arrays. \n\n1. `function compare(game, guess){` - This line defines a function called `compare` that takes two arrays as input, `game` and `guess`. \n2. `return game.map((x,i) => Math.abs(x-guess[i]));` - This line returns an array of the absolute difference between the elements of the two arrays. \n\n    a. `game.map` - This method creates a new array with the results of calling a provided function on every element in the calling array. \n\n    b. `(x,i) => Math.abs(x-guess[i])` - This is the function that is called on every element in `game`. It takes two arguments, `x` and `i`, which represent the current element and its index in the `game` array. It subtracts the corresponding element in `guess` from `x` and takes the absolute value of the result. \n\n    c. `Math.abs` - This is a built-in JavaScript function that returns the absolute value of a number. \n\n\n### Racket version\n\n#lang racket\n\n(define (compare game guess)\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (remove_duplicates numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_duplicates))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction remove_duplicates(numbers){\n  let c = {};\n  numbers.forEach(n => c[n] = (c[n] || 0) + 1);\n  return numbers.filter(n => c[n] <= 1);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `remove_duplicates` that takes an array of numbers as an argument. The function returns a new array that contains only the unique numbers from the original array. \n\nThe function works by creating an object called `c` that will be used to count the number of times each number appears in the input array. The `forEach` method is used to loop through each number in the input array. For each number, the code checks if it already exists as a key in the `c` object. If it does, the value associated with that key is incremented by 1. If it doesn't, a new key is created with a value of 1. \n\nAfter the `forEach` loop is finished, the `filter` method is used to create a new array that contains only the numbers from the input array that appear once (i.e., have a count of 1 in the `c` object). The `filter` method works by looping through each number in the input array and only including it in the new array if the count associated with that number in the `c` object is less than or equal to 1. \n\n\n### Racket version\n\n#lang racket\n\n(define (remove_duplicates numbers)\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (parse_nested_parens paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3) 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4) 0.001)\n    (check-within (candidate \"(()(())((())))\") (list 4) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction parse_nested_parens(paren_string){\n  function parse_paren_group(s){\n    let depth = 0;\n    let max_depth = 0;\n    for (let c of s){\n      if (c === '('){\n        depth += 1;\n        max_depth = Math.max(depth, max_depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ').filter(x => x).map(parse_paren_group);\n}\n\n### Explanation\n\nThe code is an implementation of a function `parse_nested_parens` that takes a string of parentheses and returns an array of integers representing the maximum depth of nested parentheses in each group of parentheses in the input string. The function works by first defining an inner function `parse_paren_group` that takes a string of parentheses and returns the maximum depth of nested parentheses in that string. The outer function then splits the input string into groups of parentheses, filters out any empty strings, and maps the `parse_paren_group` function over each group to get the maximum depth of nested parentheses.\n\nThe `parse_paren_group` function works by iterating over each character in the input string and keeping track of the current depth of nested parentheses. Whenever an opening parenthesis is encountered, the depth is incremented and the maximum depth seen so far is updated if necessary. Whenever a closing parenthesis is encountered, the depth is decremented. Finally, the maximum depth seen is returned.\n\n\n### Racket version\n\n#lang racket\n\n(define (parse_nested_parens paren_string)\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (even_odd_count num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_count))\n    (check-within (candidate 7) (list 0 1) 0.001)\n    (check-within (candidate -78) (list 1 1) 0.001)\n    (check-within (candidate 3452) (list 2 2) 0.001)\n    (check-within (candidate 346211) (list 3 3) 0.001)\n    (check-within (candidate -345821) (list 3 3) 0.001)\n    (check-within (candidate -2) (list 1 0) 0.001)\n    (check-within (candidate -45347) (list 2 3) 0.001)\n    (check-within (candidate 0) (list 1 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction even_odd_count(num){\n  let even_count = 0;\n  let odd_count = 0;\n  for(let i of String(Math.abs(num))){\n    if(parseInt(i)%2 === 0){\n      even_count += 1;\n    }else{\n      odd_count += 1;\n    }\n  }\n  return [even_count, odd_count];\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns a list of two integers. The first integer is the count of even digits in the input integer and the second integer is the count of odd digits in the input integer.\n\n1. Declare a function called `even_odd_count` that takes a parameter called `num`.\n2. Declare two variables called `even_count` and `odd_count` and initialize them to 0.\n3. Use a for-of loop to iterate over the characters of the string representation of the absolute value of `num`.\n4. Declare a variable called `i` that represents the current character in the loop.\n5. Use the `parseInt` function to convert `i` to an integer and check if it is even by using the modulus operator `%` to check if it is divisible by 2.\n6. If `i` is even, increment `even_count` by 1. Otherwise, increment `odd_count` by 1.\n7. Return a list of `even_count` and `odd_count`.\n\n\n### Racket version\n\n#lang racket\n\n(define (even_odd_count num)\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fruit_distribution s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fruit_distribution))\n    (check-within (candidate \"5 apples and 6 oranges\" 19) 8 0.001)\n    (check-within (candidate \"5 apples and 6 oranges\" 21) 10 0.001)\n    (check-within (candidate \"0 apples and 1 oranges\" 3) 2 0.001)\n    (check-within (candidate \"1 apples and 0 oranges\" 3) 2 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 100) 95 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 5) 0 0.001)\n    (check-within (candidate \"1 apples and 100 oranges\" 120) 19 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction fruit_distribution(s, n){\n  let lis = []\n  for(let i of s.split(' ')){\n    if(i.match(/\\d+/)){\n      lis.push(parseInt(i))\n    }\n  }\n  return n - lis.reduce((a,b)=>a+b,0)\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments, a string and a number. The string is expected to contain a list of fruits and their quantities. The number is the total number of fruits that are to be distributed. The function returns the number of fruits that are left to be distributed.\n\n1. `function fruit_distribution(s, n){` - This line defines a function called `fruit_distribution` that takes two arguments, `s` and `n`.\n\n2. `let lis = []` - This line initializes an empty array called `lis`.\n\n3. `for(let i of s.split(' ')){` - This line starts a loop that iterates over each element of the array returned by splitting the string `s` at each space character.\n\n4. `if(i.match(/\\d+/)){` - This line checks if the current element `i` contains one or more digits.\n\n5. `lis.push(parseInt(i))` - This line converts the current element `i` to an integer and adds it to the `lis` array.\n\n6. `return n - lis.reduce((a,b)=>a+b,0)` - This line returns the difference between the number `n` and the sum of all the elements in the `lis` array. The `reduce` method is used to sum all the elements in the array. The `0` argument is the initial value of the accumulator `a`. The `a` and `b` arguments represent the current and next elements of the array being summed. The `parseInt` function is used to convert the elements to integers before they are summed. \n\n\n### Racket version\n\n#lang racket\n\n(define (fruit_distribution s n)\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_xor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n    (check-within (candidate \"111000\" \"101010\") \"010010\" 0.001)\n    (check-within (candidate \"1\" \"1\") \"0\" 0.001)\n    (check-within (candidate \"0101\" \"0000\") \"0101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction string_xor(a, b){\n  let result = '';\n  for(let i=0; i<a.length; i++){\n    result += a[i] === b[i] ? '0' : '1';\n  }\n  return result;\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes two strings, `a` and `b`, and returns a string that represents the XOR of the two strings. The XOR operation is performed on each character of the two strings, and the result is a string of the same length as the input strings.\n\nThe function is defined using the `function` keyword, followed by the name of the function, `string_xor`, and the parameters, `a` and `b`, in parentheses. The function body is enclosed in curly braces.\n\nThe first line of the function body declares a variable `result` and initializes it to an empty string. This variable will be used to accumulate the result of the XOR operation.\n\nThe next line of the function body starts a `for` loop that iterates over the indices of the characters in the string `a`. The loop variable `i` is initialized to 0, and the loop condition is `i<a.length`, which means that the loop will continue as long as `i` is less than the length of the string `a`. The loop variable `i` is incremented by 1 at the end of each iteration.\n\nInside the loop, the result of the XOR operation on the `i`-th characters of `a` and `b` is computed using the ternary operator `? :`. If the `i`-th characters of `a` and `b` are equal, the result is `'0'`, otherwise it is `'1'`. The resulting character is appended to the `result` string using the `+=` operator.\n\nAfter the loop has finished, the `result` string is returned as the result of the function.\n\n\n### Racket version\n\n#lang racket\n\n(define (string_xor a b)\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (strlen string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strlen))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"x\") 1 0.001)\n    (check-within (candidate \"asdasnakj\") 9 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction strlen(string){\n  return string.length;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `strlen` that takes a string as an argument and returns the length of the string. The `length` property of a string object returns the number of characters in the string. The function is defined using the `function` keyword, followed by the name of the function, `strlen`, and the parameter, `string`. The function body consists of a single line that returns the length of the string using the `length` property. \n\n\n### Racket version\n\n#lang racket\n\n(define (strlen string)\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_sequence n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_sequence))\n    (check-within (candidate 0) \"0\" 0.001)\n    (check-within (candidate 3) \"0 1 2 3\" 0.001)\n    (check-within (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction string_sequence(n){\n  return [...Array(n+1).keys()].join(' ');\n}\n\n### Explanation\n\nThe code is an implementation of a function called `string_sequence` that takes in an integer `n` and returns a string of space separated integers from 0 to `n`. \n\n1. `function string_sequence(n){` declares a function called `string_sequence` that takes in an integer `n`.\n2. `return [...Array(n+1).keys()].join(' ');` returns a string of space separated integers from 0 to `n`.\n    1. `Array(n+1)` creates an array of length `n+1` with `undefined` values.\n    2. `[...Array(n+1).keys()]` spreads the keys of the array into a new array. The keys are the integers from 0 to `n`.\n    3. `.join(' ')` joins the array with a space separator to create a string of space separated integers from 0 to `n`.\n\n\n### Racket version\n\n#lang racket\n\n(define (string_sequence n)\n"
  },
  {
    "name": "HumanEval_141_file_name_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (file_name_check file_name)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_141_file_name_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate file_name_check))\n    (check-within (candidate \"example.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"1example.dll\") \"No\" 0.001)\n    (check-within (candidate \"s1sdf3.asd\") \"No\" 0.001)\n    (check-within (candidate \"K.dll\") \"Yes\" 0.001)\n    (check-within (candidate \"MY16FILE3.exe\") \"Yes\" 0.001)\n    (check-within (candidate \"His12FILE94.exe\") \"No\" 0.001)\n    (check-within (candidate \"_Y.txt\") \"No\" 0.001)\n    (check-within (candidate \"?aREYA.exe\") \"No\" 0.001)\n    (check-within (candidate \"/this_is_valid.dll\") \"No\" 0.001)\n    (check-within (candidate \"this_is_valid.wow\") \"No\" 0.001)\n    (check-within (candidate \"this_is_valid.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"this_is_valid.txtexe\") \"No\" 0.001)\n    (check-within (candidate \"#this2_i4s_5valid.ten\") \"No\" 0.001)\n    (check-within (candidate \"@this1_is6_valid.exe\") \"No\" 0.001)\n    (check-within (candidate \"this_is_12valid.6exe4.txt\") \"No\" 0.001)\n    (check-within (candidate \"all.exe.txt\") \"No\" 0.001)\n    (check-within (candidate \"I563_No.exe\") \"Yes\" 0.001)\n    (check-within (candidate \"Is3youfault.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"no_one#knows.dll\") \"Yes\" 0.001)\n    (check-within (candidate \"1I563_Yes3.exe\") \"No\" 0.001)\n    (check-within (candidate \"I563_Yes3.txtt\") \"No\" 0.001)\n    (check-within (candidate \"final..txt\") \"No\" 0.001)\n    (check-within (candidate \"final132\") \"No\" 0.001)\n    (check-within (candidate \"_f4indsartal132.\") \"No\" 0.001)\n    (check-within (candidate \".txt\") \"No\" 0.001)\n    (check-within (candidate \"s.\") \"No\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction file_name_check(file_name){\n  let suf = ['txt', 'exe', 'dll'];\n  let lst = file_name.split('.');\n  if(lst.length != 2){\n    return 'No';\n  }\n  if(!suf.includes(lst[1])){\n    return 'No';\n  }\n  if(lst[0].length == 0 || !lst[0][0].match(/[a-zA-Z]/)){\n    return 'No';\n  }\n  let t = lst[0].match(/\\d/g);\n  if(t != null && t.length > 3){\n    return 'No';\n  }\n  return 'Yes';\n}\n\n### Explanation\n\nThe code is an implementation of a function called `file_name_check` that takes in a string called `file_name` and returns either `'Yes'` or `'No'` depending on whether the input string is a valid file name or not.\n\nThe function first creates an array called `suf` that contains three file extensions: `'txt'`, `'exe'`, and `'dll'`. \n\nIt then splits the input string `file_name` into two parts using the `.` character as a delimiter. The resulting array is stored in a variable called `lst`. If the length of `lst` is not equal to 2, the function returns `'No'` because a valid file name should have exactly one `.` character.\n\nNext, the function checks if the second part of `lst` (i.e., the file extension) is in the `suf` array. If it is not, the function returns `'No'` because a valid file name should have one of the three file extensions in `suf`.\n\nThe function then checks if the first part of `lst` (i.e., the file name) starts with a letter. If it does not, the function returns `'No'` because a valid file name should start with a letter.\n\nFinally, the function checks if the first part of `lst` contains at most three digits. If it contains more than three digits, the function returns `'No'` because a valid file name should have at most three digits in its name.\n\nIf all the above checks pass, the function returns `'Yes'`, indicating that the input string is a valid file name.\n\n\n### Racket version\n\n#lang racket\n\n(define (file_name_check file_name)\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (can_arrange arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate can_arrange))\n    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)\n    (check-within (candidate (list 1 2 4 5)) -1 0.001)\n    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)\n    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)\n    (check-within (candidate (list )) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction can_arrange(arr){\n  let ind=-1\n  let i=1\n  while (i<arr.length){\n    if (arr[i]<arr[i-1]){\n      ind=i\n    }\n    i+=1\n  }\n  return ind\n}\n\n### Explanation\n\nThe code is an implementation of a function called `can_arrange` that takes an array as input and returns an integer. The function checks whether the input array can be arranged in non-decreasing order by swapping at most one pair of elements. If the array can be arranged in non-decreasing order, the function returns -1. Otherwise, it returns the index of the element that needs to be swapped to arrange the array in non-decreasing order.\n\nThe function starts by initializing two variables `ind` and `i` to -1 and 1, respectively. The variable `ind` is used to keep track of the index of the element that needs to be swapped, while `i` is used to iterate over the array.\n\nThe function then enters a while loop that continues until `i` is equal to the length of the input array. Inside the loop, the function checks whether the current element is less than the previous element. If it is, the function sets `ind` to the current index `i`. This means that the current element needs to be swapped with the previous element to arrange the array in non-decreasing order.\n\nFinally, the function returns `ind`. If `ind` is still equal to -1, this means that the array can be arranged in non-decreasing order without any swaps, and the function returns -1.\n\n\n### Racket version\n\n#lang racket\n\n(define (can_arrange arr)\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate (list 4 88)) 88 0.001)\n    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)\n    (check-within (candidate (list 4 0 6 7)) 0 0.001)\n    (check-within (candidate (list 4 4 6 8)) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction add(lst){\n  return lst.filter((x,i) => i%2==1 && x%2==0).reduce((a,b) => a+b,0)\n}\n\n### Explanation\n\nThe code is an implementation of a function called `add` that takes a list `lst` as input. The function returns the sum of all even elements at odd indices of the input list. \n\nThe function first filters the input list to only include elements that are even and at odd indices. This is done using the `filter` method of the `lst` object. The `filter` method takes a function as input that returns a boolean value. If the function returns `true`, the element is included in the filtered list. If it returns `false`, the element is excluded. In this case, the function is defined using an arrow function that takes two arguments: `x` and `i`. `x` is the current element being processed, and `i` is its index in the list. The function returns `true` if `i` is odd and `x` is even, and `false` otherwise.\n\nThe filtered list is then passed to the `reduce` method of the `lst` object. The `reduce` method takes a function as input that combines all elements of the list into a single value. In this case, the function is defined using an arrow function that takes two arguments: `a` and `b`. `a` is the accumulated value so far, and `b` is the current element being processed. The function returns the sum of `a` and `b`. The `reduce` method starts with an initial value of `0`, and applies the function to each element of the filtered list in turn. The final result is the sum of all even elements at odd indices of the input list.\n\n\n### Racket version\n\n#lang racket\n\n(define (add lst)\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (intersperse numbers delimeter)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersperse))\n    (check-within (candidate (list ) 7) (list ) 0.001)\n    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)\n    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction intersperse(numbers, delimeter){\n  if (!numbers.length){\n    return [];\n  }\n\n  let result = [];\n\n  for (let i = 0; i < numbers.length - 1; i++){\n    result.push(numbers[i]);\n    result.push(delimeter);\n  }\n\n  result.push(numbers[numbers.length - 1]);\n\n  return result;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `intersperse` that takes two arguments: an array of numbers called `numbers` and a string called `delimeter`. The function returns a new array that contains the same numbers as the input array, but with the `delimeter` string inserted between each pair of numbers.\n\nThe function first checks if the input array is empty. If it is, the function returns an empty array.\n\nIf the input array is not empty, the function initializes an empty array called `result`.\n\nThe function then loops through the input array, adding each number to the `result` array, followed by the `delimeter` string. The loop stops before the last number in the input array, so that the `delimeter` string is not added after the last number.\n\nAfter the loop, the function adds the last number in the input array to the `result` array.\n\nFinally, the function returns the `result` array.\n\n\n### Racket version\n\n#lang racket\n\n(define (intersperse numbers delimeter)\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (match_parens lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate match_parens))\n    (check-within (candidate (list \"()(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \")\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(())\" \"())())\")) \"No\" 0.001)\n    (check-within (candidate (list \")())\" \"(()()(\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"(())))\" \"(()())((\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"()\" \"())\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(\" \"()))()\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"((((\" \"((())\")) \"No\" 0.001)\n    (check-within (candidate (list \")(()\" \"(()(\")) \"No\" 0.001)\n    (check-within (candidate (list \")(\" \")(\")) \"No\" 0.001)\n    (check-within (candidate (list \"(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \"(\")) \"Yes\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction match_parens(lst){\n  function check(s){\n    let val = 0;\n    for(let i of s){\n      if(i === '('){\n        val++;\n      }else{\n        val--;\n      }\n      if(val < 0){\n        return false;\n      }\n    }\n    return val === 0;\n  }\n  \n  let S1 = lst[0] + lst[1];\n  let S2 = lst[1] + lst[0];\n  \n  return check(S1) || check(S2) ? 'Yes' : 'No';\n}\n\n### Explanation\n\nThe code is an implementation of a function called `match_parens` that takes a list of two strings as input and returns a string 'Yes' if the two strings can be concatenated in such a way that the resulting string has balanced parentheses, and 'No' otherwise.\n\nThe function first defines an inner function called `check` that takes a string as input and returns true if the string has balanced parentheses and false otherwise. The function works by iterating over the string and keeping track of the number of open and closed parentheses encountered so far. If at any point the number of closed parentheses encountered is greater than the number of open parentheses, the function returns false. If the iteration completes and the number of open and closed parentheses is equal, the function returns true.\n\nThe function then concatenates the two input strings in two different orders and stores them in variables `S1` and `S2`.\n\nFinally, the function returns 'Yes' if either `S1` or `S2` has balanced parentheses, and 'No' otherwise. This is done using the ternary operator, which is a shorthand way of writing an if-else statement. If the condition before the ? is true, the expression before the : is returned, otherwise the expression after the : is returned. In this case, if either `check(S1)` or `check(S2)` is true, the function returns 'Yes', otherwise it returns 'No'.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (match_parens lst)\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_by_substring strings substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"grunt\" \"trumpet\" \"prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction filter_by_substring(strings, substring){\n  return strings.filter(x => x.includes(substring))\n}\n\n### Explanation\n\nThe code is an implementation of a function called `filter_by_substring` that takes two arguments, `strings` and `substring`. The function returns a new array that contains all the elements of the `strings` array that include the `substring`.\n\nThe `filter` method is used to create a new array that contains only the elements of the original array that pass a certain test. In this case, the test is whether the element includes the `substring`. The `filter` method takes a callback function as its argument, which is executed for each element of the array. The callback function is defined using an arrow function expression, which is a shorthand way of defining a function.\n\nThe `includes` method is used to check whether the `substring` is present in the element. If it is, the `includes` method returns `true`, and the element is included in the new array. If it is not, the `includes` method returns `false`, and the element is not included in the new array.\n\nThe `filter_by_substring` function returns the new array that contains only the elements of the `strings` array that include the `substring`.\n\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_substring strings substring)\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (find_max words)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_max))\n    (check-within (candidate (list \"name\" \"of\" \"string\")) \"string\" 0.001)\n    (check-within (candidate (list \"name\" \"enam\" \"game\")) \"enam\" 0.001)\n    (check-within (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\" 0.001)\n    (check-within (candidate (list \"abc\" \"cba\")) \"abc\" 0.001)\n    (check-within (candidate (list \"play\" \"this\" \"game\" \"of\" \"footbott\")) \"footbott\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\" 0.001)\n    (check-within (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\" 0.001)\n    (check-within (candidate (list \"b\")) \"b\" 0.001)\n    (check-within (candidate (list \"play\" \"play\" \"play\")) \"play\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction find_max(words){\n  return words.sort((a, b) => {\n    return (new Set(b)).size - (new Set(a)).size || a.localeCompare(b);\n  })[0];\n}\n\n### Explanation\n\nThe code is an implementation of a function called `find_max` that takes an array of strings called `words` as its argument. The function returns the string with the largest number of unique characters. If there are multiple strings with the same number of unique characters, the function returns the string that comes first in lexicographic order.\n\nThe function works by first sorting the array of strings in descending order of the number of unique characters in each string. It does this by calling the `sort` method on the `words` array and passing in a comparison function as an argument. The comparison function takes two strings, `a` and `b`, and returns a negative number if `a` should come before `b`, a positive number if `b` should come before `a`, and zero if they are equal.\n\nThe comparison function calculates the number of unique characters in each string by creating a new `Set` object for each string and getting the size of the set. It then subtracts the size of the set for `a` from the size of the set for `b`. If the result is non-zero, it returns the result. Otherwise, it uses the `localeCompare` method to compare the two strings lexicographically and returns the result of that comparison.\n\nFinally, the function returns the first element of the sorted array, which will be the string with the largest number of unique characters.\n\n\n### Racket version\n\n#lang racket\n\n(define (find_max words)\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (generate_integers a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate generate_integers))\n    (check-within (candidate 2 10) (list 2 4 6 8) 0.001)\n    (check-within (candidate 10 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 132 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 17 89) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction generate_integers(a, b){\n  let lower = Math.max(2, Math.min(a, b));\n  let upper = Math.min(8, Math.max(a, b));\n  \n  return Array.from({length: upper-lower+1}, (_, i) => i+lower).filter(i => i%2 === 0);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `generate_integers` that takes two arguments `a` and `b`. The function returns an array of even integers between `a` and `b` inclusive. If `a` is greater than `b`, the function swaps the values of `a` and `b`.\n\nThe first line of the function declares the function name and its arguments. \n\n```javascript\nfunction generate_integers(a, b){\n```\n\nThe second line of the function declares a variable `lower` and assigns it the value of the maximum of 2 and the minimum of `a` and `b`. \n\n```javascript\n  let lower = Math.max(2, Math.min(a, b));\n```\n\nThe third line of the function declares a variable `upper` and assigns it the value of the minimum of 8 and the maximum of `a` and `b`. \n\n```javascript\n  let upper = Math.min(8, Math.max(a, b));\n```\n\nThe fourth line of the function returns an array of length `upper-lower+1` using the `Array.from` method. The `Array.from` method creates a new array from an iterable object. In this case, the iterable object is an object with a `length` property of `upper-lower+1`. The second argument of the `Array.from` method is a mapping function that maps each element of the new array to a value. In this case, the mapping function is a lambda function that takes two arguments, `_` and `i`, and returns `i+lower`. The `_` argument is a placeholder for the index of the element, which is not used in the mapping function. The `i` argument is the value of the index of the element, which is used to calculate the value of the element. \n\n```javascript\n  return Array.from({length: upper-lower+1}, (_, i) => i+lower)\n```\n\nThe fifth line of the function filters the array returned by the `Array.from` method to include only even integers. The `filter` method creates a new array with all elements that pass the test implemented by the provided function. In this case, the provided function is a lambda function that takes one argument `i` and returns `i%2 === 0`, which tests whether `i` is even. \n\n```javascript\n  .filter(i => i%2 === 0);\n}\n```\n\n\n### Racket version\n\n#lang racket\n\n(define (generate_integers a b)\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (exchange lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate exchange))\n    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) \"YES\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 4)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 3)) \"NO\" 0.001)\n    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) \"NO\" 0.001)\n    (check-within (candidate (list 100 200) (list 200 200)) \"YES\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction exchange(lst1, lst2){\n  let odd = lst1.filter(i => i%2 === 1).length;\n  let even = lst2.filter(i => i%2 === 0).length;\n  return even >= odd ? \"YES\" : \"NO\";\n}\n\n### Explanation\n\nThe code is an implementation of a function called `exchange` that takes two lists as arguments. The function returns \"YES\" if the number of even numbers in the second list is greater than or equal to the number of odd numbers in the first list. Otherwise, it returns \"NO\".\n\n1. The function `exchange` takes two arguments `lst1` and `lst2`.\n2. The `filter` method is called on `lst1` with a callback function that returns true if an element is odd.\n3. The `length` property is called on the filtered list to get the number of odd elements.\n4. The result is assigned to the variable `odd`.\n5. The `filter` method is called on `lst2` with a callback function that returns true if an element is even.\n6. The `length` property is called on the filtered list to get the number of even elements.\n7. The result is assigned to the variable `even`.\n8. The function returns \"YES\" if `even` is greater than or equal to `odd`, otherwise it returns \"NO\".\n\n\n### Racket version\n\n#lang racket\n\n(define (exchange lst1 lst2)\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (int_to_mini_roman number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate int_to_mini_roman))\n    (check-within (candidate 19) \"xix\" 0.001)\n    (check-within (candidate 152) \"clii\" 0.001)\n    (check-within (candidate 251) \"ccli\" 0.001)\n    (check-within (candidate 426) \"cdxxvi\" 0.001)\n    (check-within (candidate 500) \"d\" 0.001)\n    (check-within (candidate 1) \"i\" 0.001)\n    (check-within (candidate 4) \"iv\" 0.001)\n    (check-within (candidate 43) \"xliii\" 0.001)\n    (check-within (candidate 90) \"xc\" 0.001)\n    (check-within (candidate 94) \"xciv\" 0.001)\n    (check-within (candidate 532) \"dxxxii\" 0.001)\n    (check-within (candidate 900) \"cm\" 0.001)\n    (check-within (candidate 994) \"cmxciv\" 0.001)\n    (check-within (candidate 1000) \"m\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction int_to_mini_roman(number){\n  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n  let sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"];\n  let i = 12;\n  let res = '';\n  while(number){\n    let div = Math.floor(number / num[i]);\n    number %= num[i];\n    while(div){\n      res += sym[i];\n      div--;\n    }\n    i--;\n  }\n  return res.toLowerCase();\n}\n\n### Explanation\n\nThe code is an implementation of a function that converts an integer to a Roman numeral. It takes an integer as an argument and returns the Roman numeral representation of that integer.\n\nThe function starts by defining two arrays: `num` and `sym`. `num` contains the integer values of the Roman numerals, and `sym` contains the corresponding symbols. For example, `num[0]` is 1, and `sym[0]` is \"I\".\n\nThe function then initializes two variables: `i` and `res`. `i` is set to 12, which is the index of the largest Roman numeral in the `num` array (1000). `res` is an empty string that will be used to build the Roman numeral representation of the input integer.\n\nThe function then enters a `while` loop that continues as long as `number` is truthy (i.e. not 0). Inside the loop, the function calculates the number of times the current Roman numeral can be subtracted from `number` using integer division (`Math.floor(number / num[i])`). It then subtracts that value from `number` using the modulus operator (`number %= num[i]`). Finally, it adds the corresponding symbol to `res` that many times using another `while` loop.\n\nAfter the inner `while` loop completes, `i` is decremented to move on to the next smaller Roman numeral. The outer `while` loop continues until `number` is 0.\n\nFinally, the function returns `res` in lowercase. This is because Roman numerals are traditionally written in uppercase, but the prompt specifies that the output should be in lowercase.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (int_to_mini_roman number)\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_equal_to_sum_even n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_equal_to_sum_even))\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #t 0.001)\n    (check-within (candidate 11) #f 0.001)\n    (check-within (candidate 12) #t 0.001)\n    (check-within (candidate 13) #f 0.001)\n    (check-within (candidate 16) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_equal_to_sum_even(n){\n  return n%2 == 0 && n >= 8;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `is_equal_to_sum_even` that takes an argument `n`. The function returns a boolean value that is `true` if `n` is even and greater than or equal to 8. Otherwise, it returns `false`.\n\nThe function first checks if `n` is even by checking if the remainder of `n` divided by 2 is equal to 0. If `n` is even, the function then checks if `n` is greater than or equal to 8. If both conditions are true, the function returns `true`. Otherwise, it returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_equal_to_sum_even n)\n"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (decimal_to_binary decimal)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_79_decimal_to_binary.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate decimal_to_binary))\n    (check-within (candidate 0) \"db0db\" 0.001)\n    (check-within (candidate 32) \"db100000db\" 0.001)\n    (check-within (candidate 103) \"db1100111db\" 0.001)\n    (check-within (candidate 15) \"db1111db\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction decimal_to_binary(decimal){\n  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes in a decimal number and returns a string representation of the binary equivalent of the decimal number. \n\n1. `function decimal_to_binary(decimal){` - This line declares a function called `decimal_to_binary` that takes in a single parameter called `decimal`.\n2. `return \"db\" + decimal.toString(2) + \"db\";` - This line returns a string that concatenates the string \"db\" with the binary representation of the decimal number and the string \"db\". The `toString()` method is called on the decimal number with a radix of 2 to convert it to a binary string.\n\n\n### Racket version\n\n#lang racket\n\n(define (decimal_to_binary decimal)\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_third l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_third))\n    (check-within (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5) 0.001)\n    (check-within (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5) 0.001)\n    (check-within (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5) 0.001)\n    (check-within (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction sort_third(l){\n  l = l.slice()\n  l.filter((_, i) => i % 3 === 0).sort().forEach((x, i) => l[3 * i] = x)\n  return l\n}\n\n### Explanation\n\nThe code is an implementation of a function that sorts every third element of a list. Here is a line by line explanation of the code:\n\n```function sort_third(l){```\nThis line defines a function called `sort_third` that takes a list `l` as its argument.\n\n```l = l.slice()```\nThis line creates a copy of the input list `l` using the `slice()` method. This is done to avoid modifying the original list.\n\n```l.filter((_, i) => i % 3 === 0)```\nThis line filters the list `l` to only include elements whose index is a multiple of 3. The `_` is a placeholder for the value of the element, which is not used in this case.\n\n```l.filter((_, i) => i % 3 === 0).sort()```\nThis line sorts the filtered list in ascending order using the `sort()` method.\n\n```l.filter((_, i) => i % 3 === 0).sort().forEach((x, i) => l[3 * i] = x)```\nThis line iterates over the sorted list using the `forEach()` method. For each element `x` and its index `i`, it sets the value of the element at index `3 * i` in the original list `l` to `x`.\n\n```return l```\nThis line returns the modified list `l`.\n\n\n### Racket version\n\n#lang racket\n\n(define (sort_third l)\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (simplify x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate simplify))\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/6\" \"2/1\") #f 0.001)\n    (check-within (candidate \"5/1\" \"3/1\") #t 0.001)\n    (check-within (candidate \"7/10\" \"10/2\") #f 0.001)\n    (check-within (candidate \"2/10\" \"50/10\") #t 0.001)\n    (check-within (candidate \"7/2\" \"4/2\") #t 0.001)\n    (check-within (candidate \"11/6\" \"6/1\") #t 0.001)\n    (check-within (candidate \"2/3\" \"5/2\") #f 0.001)\n    (check-within (candidate \"5/2\" \"3/5\") #f 0.001)\n    (check-within (candidate \"2/4\" \"8/4\") #t 0.001)\n    (check-within (candidate \"2/4\" \"4/2\") #t 0.001)\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/5\" \"1/5\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction simplify(x, n){\n  let [a, b] = x.split(\"/\");\n  let [c, d] = n.split(\"/\");\n  let numerator = parseInt(a) * parseInt(c);\n  let denom = parseInt(b) * parseInt(d);\n  return numerator/denom == parseInt(numerator/denom);\n}\n\n### Explanation\n\nThe code is an implementation of a function `simplify` that takes two arguments `x` and `n`. The function returns a boolean value. The function is defined using the `function` keyword.\n\nThe function uses destructuring assignment to extract the numerator and denominator from the `x` and `n` arguments. The `split` method is used to split the string at the `/` character and the resulting array is destructured into the `a` and `b` variables for `x` and `c` and `d` variables for `n`.\n\n```\nlet [a, b] = x.split(\"/\");\nlet [c, d] = n.split(\"/\");\n```\n\nThe numerator is calculated by multiplying `a` and `c` and the denominator is calculated by multiplying `b` and `d`. The `parseInt` function is used to convert the string values to integers.\n\n```\nlet numerator = parseInt(a) * parseInt(c);\nlet denom = parseInt(b) * parseInt(d);\n```\n\nThe function then returns a boolean value indicating whether the simplified fraction is equal to the original fraction. This is done by dividing the numerator by the denominator and checking if the result is equal to the integer value of the division.\n\n```\nreturn numerator/denom == parseInt(numerator/denom);\n```\n\n\n### Racket version\n\n#lang racket\n\n(define (simplify x n)\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solve s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate \"AsDf\") \"aSdF\" 0.001)\n    (check-within (candidate \"1234\") \"4321\" 0.001)\n    (check-within (candidate \"ab\") \"AB\" 0.001)\n    (check-within (candidate \"#a@C\") \"#A@c\" 0.001)\n    (check-within (candidate \"#AsdfW^45\") \"#aSDFw^45\" 0.001)\n    (check-within (candidate \"#6@2\") \"2@6#\" 0.001)\n    (check-within (candidate \"#$a^D\") \"#$A^d\" 0.001)\n    (check-within (candidate \"#ccc\") \"#CCC\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction solve(s){\n  let flg = 0;\n  let idx = 0;\n  let new_str = s.split('');\n  \n  for(let i of s){\n    if(i.match(/[a-z]/i)){\n      new_str[idx] = i === i.toUpperCase() ? i.toLowerCase() : i.toUpperCase();\n      flg = 1;\n    }\n    idx++;\n  }\n  \n  if(flg === 0){\n    return new_str.reverse().join('');\n  }\n  \n  return new_str.join('');\n}\n\n### Explanation\n\nThe code is an implementation of a function called `solve` that takes a string `s` as an argument. The function returns a new string that is the same as the input string except that all the letters in the string are swapped to their opposite case. For example, if the input string is \"Hello World\", the output string will be \"hELLO wORLD\". If the input string contains no letters, the output string will be the reverse of the input string.\n\nThe function starts by initializing two variables, `flg` and `idx`, to 0. It also creates a new array called `new_str` that is a copy of the input string split into individual characters.\n\nThe function then loops through each character in the input string using a `for...of` loop. For each character, it checks if it is a letter using a regular expression that matches any letter (case-insensitive). If the character is a letter, it swaps its case by checking if it is uppercase using the `toUpperCase()` method. If it is uppercase, it converts it to lowercase using the `toLowerCase()` method, and vice versa. It also sets the `flg` variable to 1 to indicate that at least one letter has been swapped.\n\nAfter processing all the characters in the input string, the function checks if any letters were swapped by checking the value of the `flg` variable. If no letters were swapped, it returns the reverse of the input string using the `reverse()` method and then joining the characters back together using the `join()` method.\n\nIf at least one letter was swapped, the function returns the modified `new_str` array joined back together into a string using the `join()` method. \n\n\n### Racket version\n\n#lang racket\n\n(define (solve s)\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (right_angle_triangle a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n    (check-within (candidate 3 4 5) #t 0.001)\n    (check-within (candidate 1 2 3) #f 0.001)\n    (check-within (candidate 10 6 8) #t 0.001)\n    (check-within (candidate 2 2 2) #f 0.001)\n    (check-within (candidate 7 24 25) #t 0.001)\n    (check-within (candidate 10 5 7) #f 0.001)\n    (check-within (candidate 5 12 13) #t 0.001)\n    (check-within (candidate 15 8 17) #t 0.001)\n    (check-within (candidate 48 55 73) #t 0.001)\n    (check-within (candidate 1 1 1) #f 0.001)\n    (check-within (candidate 2 2 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction right_angle_triangle(a, b, c){\n  return a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b\n}\n\n### Explanation\n\nThe code is an implementation of a function that checks if a triangle is a right angle triangle. The function takes in three arguments `a`, `b`, and `c`, which represent the length of the sides of the triangle. The function returns a boolean value, `true` if the triangle is a right angle triangle and `false` otherwise.\n\nThe function checks if the square of one side of the triangle is equal to the sum of the squares of the other two sides. This is done for all three sides of the triangle. If any of the sides satisfy this condition, then the function returns `true`, otherwise it returns `false`.\n\nThe code uses the `==` operator to check if the square of one side of the triangle is equal to the sum of the squares of the other two sides. If the condition is true, then the function returns `true`, otherwise it returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (right_angle_triangle a b c)\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (double_the_difference lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate double_the_difference))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 5.0 4.0)) 25 0.001)\n    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)\n    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)\n    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)\n    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)\n    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction double_the_difference(lst){\n  return lst.filter(i => i > 0 && i%2!=0 && !/\\./.test(i)).reduce((a,b) => a + b**2, 0)\n}\n\n### Explanation\n\nThe code is an implementation of a function called `double_the_difference` that takes a list of numbers as an argument. The function filters the list to only include positive odd integers that do not contain a decimal point. It then squares each of the filtered integers and returns the sum of the squares multiplied by 2.\n\nThe first line of the function defines the function name and its argument, `lst`. \n\nThe second line filters the list `lst` using the `filter()` method. The `filter()` method creates a new array with all elements that pass the test implemented by the provided function. In this case, the test function is an arrow function that checks if the element is greater than 0, is odd, and does not contain a decimal point. The `!/\\./.test(i)` part checks if the element does not contain a decimal point. \n\nThe third line uses the `reduce()` method to sum the squares of the filtered elements. The `reduce()` method applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value. In this case, the function is an arrow function that adds the square of the current element to the accumulator. The `0` at the end is the initial value of the accumulator.\n\nFinally, the function returns the sum of the squares multiplied by 2. \n\n\n### Racket version\n\n#lang racket\n\n(define (double_the_difference lst)\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (compare_one a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare_one))\n    (check-within (candidate 1 2) 2 0.001)\n    (check-within (candidate 1 2.5) 2.5 0.001)\n    (check-within (candidate 2 3) 3 0.001)\n    (check-within (candidate 5 6) 6 0.001)\n    (check-within (candidate 1 \"2,3\") \"2,3\" 0.001)\n    (check-within (candidate \"5,1\" \"6\") \"6\" 0.001)\n    (check-within (candidate \"1\" \"2\") \"2\" 0.001)\n    (check-within (candidate \"1\" 1) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction compare_one(a, b){\n  let temp_a = a, temp_b = b;\n  if(typeof temp_a === 'string') temp_a = temp_a.replace(',','.');\n  if(typeof temp_b === 'string') temp_b = temp_b.replace(',','.');\n  if(parseFloat(temp_a) == parseFloat(temp_b)) return null;\n  return parseFloat(temp_a) > parseFloat(temp_b) ? a : b;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `compare_one` that takes two arguments `a` and `b`. The function compares the two arguments and returns the argument with the highest value. If the two arguments are equal, the function returns `null`.\n\nThe function first creates two variables `temp_a` and `temp_b` and assigns them the values of `a` and `b`, respectively. This is done to avoid modifying the original values of `a` and `b`.\n\nNext, the function checks if `temp_a` is a string. If it is, it replaces any commas in the string with periods. This is done to ensure that the string can be parsed as a float. The same is done for `temp_b`.\n\nThe function then parses `temp_a` and `temp_b` as floats and compares them. If they are equal, the function returns `null`. Otherwise, it returns the argument with the highest value.\n\n\n### Racket version\n\n#lang racket\n\n(define (compare_one a b)\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (below_zero operations)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_zero))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)\n    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)\n    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction below_zero(operations){\n  let balance = 0;\n  \n  for(let op of operations){\n    balance += op;\n    if(balance < 0){\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n### Explanation\n\nThe code is an implementation of a function named `below_zero` which takes an array of numbers as an argument. The function returns a boolean value indicating whether the sum of the numbers in the array is negative at any point.\n\nThe function first initializes a variable named `balance` to 0.\n\nIt then loops through each element in the `operations` array using a `for...of` loop. In each iteration, it adds the current element to the `balance` variable. If the `balance` variable is less than 0, the function returns `true` indicating that the sum of the numbers in the array is negative at that point.\n\nIf the loop completes without returning `true`, the function returns `false` indicating that the sum of the numbers in the array is never negative.\n\n\n### Racket version\n\n#lang racket\n\n(define (below_zero operations)\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (greatest_common_divisor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate greatest_common_divisor))\n    (check-within (candidate 3 7) 1 0.001)\n    (check-within (candidate 10 15) 5 0.001)\n    (check-within (candidate 49 14) 7 0.001)\n    (check-within (candidate 144 60) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction greatest_common_divisor(a, b){\n  while(b){\n    [a, b] = [b, a % b]\n  }\n  return a\n}\n\n### Explanation\n\nThe code is an implementation of the Euclidean algorithm for finding the greatest common divisor of two numbers. The function takes two arguments, `a` and `b`. The algorithm works by repeatedly taking the remainder of `a` divided by `b` and setting `a` to `b` and `b` to the remainder. This is done until `b` is zero, at which point `a` is the greatest common divisor.\n\nThe function starts by defining a `while` loop that will run as long as `b` is truthy (i.e. not zero). Inside the loop, the code uses destructuring assignment to swap the values of `a` and `b`, and set `b` to the remainder of `a` divided by `b`. This is done using the modulo operator (`%`). \n\nFinally, when the loop is finished, the function returns `a`, which is the greatest common divisor of the original `a` and `b` values.\n\n\n### Racket version\n\n#lang racket\n\n(define (greatest_common_divisor a b)\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (f n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate 5) (list 1 2 6 24 15) 0.001)\n    (check-within (candidate 7) (list 1 2 6 24 15 720 28) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n    (check-within (candidate 3) (list 1 2 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction f(n){\n  let ret = [];\n  for(let i=1;i<=n;i++){\n    if(i%2==0){\n      let x = 1;\n      for(let j=1;j<=i;j++) x *= j;\n      ret.push(x);\n    }else{\n      let x = 0;\n      for(let j=1;j<=i;j++) x += j;\n      ret.push(x);\n    }\n  }\n  return ret;\n}\n\n### Explanation\n\nThe code is an implementation of a function `f` that takes an integer `n` as input and returns an array of integers. The function iterates over the integers from 1 to `n` and for each integer, it either computes the sum of the integers from 1 to `i` if `i` is odd, or the product of the integers from 1 to `i` if `i` is even. The computed value is then added to an array `ret` which is returned at the end of the function.\n\nHere is a line-by-line explanation of the code:\n\n1. `function f(n){`: This line defines a function `f` that takes an integer `n` as input.\n2. `let ret = [];`: This line initializes an empty array `ret` that will be used to store the computed values.\n3. `for(let i=1;i<=n;i++){`: This line starts a loop that iterates over the integers from 1 to `n`.\n4. `if(i%2==0){`: This line checks if the current integer `i` is even.\n5. `let x = 1;`: This line initializes a variable `x` to 1 that will be used to compute the product of the integers from 1 to `i`.\n6. `for(let j=1;j<=i;j++) x *= j;`: This line starts a loop that iterates over the integers from 1 to `i` and multiplies each integer by `x`.\n7. `ret.push(x);`: This line adds the computed value `x` to the array `ret`.\n8. `}else{`: This line is executed if the current integer `i` is odd.\n9. `let x = 0;`: This line initializes a variable `x` to 0 that will be used to compute the sum of the integers from 1 to `i`.\n10. `for(let j=1;j<=i;j++) x += j;`: This line starts a loop that iterates over the integers from 1 to `i` and adds each integer to `x`.\n11. `ret.push(x);`: This line adds the computed value `x` to the array `ret`.\n12. `}`: This line ends the `if` statement.\n13. `}`: This line ends the `for` loop.\n14. `return ret;`: This line returns the array `ret` containing the computed values.\n\n\n### Racket version\n\n#lang racket\n\n(define (f n)\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (monotonic l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n    (check-within (candidate (list 1 2 4 10)) #t 0.001)\n    (check-within (candidate (list 1 2 4 20)) #t 0.001)\n    (check-within (candidate (list 1 20 4 10)) #f 0.001)\n    (check-within (candidate (list 4 1 0 -10)) #t 0.001)\n    (check-within (candidate (list 4 1 1 0)) #t 0.001)\n    (check-within (candidate (list 1 2 3 2 5 60)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 60)) #t 0.001)\n    (check-within (candidate (list 9 9 9 9)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction monotonic(l){\n  return l.every((x, i) => i == 0 || x >= l[i-1]) || l.every((x, i) => i == 0 || x <= l[i-1]);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `monotonic` that takes a list `l` as an argument. The function returns a boolean value indicating whether the list is monotonic or not. A list is monotonic if it is either entirely non-increasing or non-decreasing. \n\nThe function uses the `every` method of the `Array` object twice. The `every` method returns `true` if every element in the array satisfies the condition specified by the callback function. Otherwise, it returns `false`.\n\nThe first `every` method checks if the list is non-decreasing. It does this by checking if every element in the list is greater than or equal to the previous element. The callback function passed to the `every` method takes two arguments: the current element `x` and its index `i`. If the index is 0, the function returns `true` because the first element has no previous element to compare to. Otherwise, the function returns `true` if the current element is greater than or equal to the previous element.\n\nThe second `every` method checks if the list is non-increasing. It does this by checking if every element in the list is less than or equal to the previous element. The callback function passed to the `every` method is similar to the one used in the first `every` method, but it checks if the current element is less than or equal to the previous element.\n\nThe `||` operator combines the two `every` method calls using logical OR. If either of the `every` method calls returns `true`, the entire expression evaluates to `true`. Otherwise, it evaluates to `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (monotonic l)\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (by_length arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate by_length))\n    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list \"Eight\" \"Five\" \"Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\") 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -1 55)) (list \"One\") 0.001)\n    (check-within (candidate (list 1 -1 3 2)) (list \"Three\" \"Two\" \"One\") 0.001)\n    (check-within (candidate (list 9 4 8)) (list \"Nine\" \"Eight\" \"Four\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction by_length(arr){\n  let dic = {\n    1: \"One\",\n    2: \"Two\",\n    3: \"Three\",\n    4: \"Four\",\n    5: \"Five\",\n    6: \"Six\",\n    7: \"Seven\",\n    8: \"Eight\",\n    9: \"Nine\"\n  };\n  let sorted_arr = arr.sort((a,b) => b-a);\n  let new_arr = [];\n  for(let var_ of sorted_arr){\n    if(dic[var_]){\n      new_arr.push(dic[var_]);\n    }\n  }\n  return new_arr;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `by_length` that takes an array of integers as input and returns a new array of strings. The strings in the new array are the English words for the integers in the input array, sorted in descending order of the length of the strings.\n\nThe function starts by defining an object called `dic` that maps integers to their English word equivalents. The object is defined using the curly brace syntax, with each key-value pair separated by a colon. The keys are integers, and the values are strings.\n\nThe function then sorts the input array in descending order using the `sort` method. The `sort` method takes a comparison function as an argument, which is used to determine the order of the elements in the sorted array. In this case, the comparison function is an arrow function that subtracts `b` from `a`, resulting in a descending order.\n\nThe function then creates a new empty array called `new_arr`. It then iterates over the sorted input array using a `for...of` loop. The loop variable is called `var_`, and it takes on the value of each element in the sorted array in turn.\n\nFor each element in the sorted array, the function checks if the `dic` object has a key that matches the value of the element. If it does, the function pushes the corresponding value (the English word) onto the `new_arr` array.\n\nFinally, the function returns the `new_arr` array.\n\n\n### Racket version\n\n#lang racket\n\n(define (by_length arr)\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (check_if_last_char_is_a_letter txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n    (check-within (candidate \"apple\") #f 0.001)\n    (check-within (candidate \"apple pi e\") #t 0.001)\n    (check-within (candidate \"eeeee\") #f 0.001)\n    (check-within (candidate \"A\") #t 0.001)\n    (check-within (candidate \"Pumpkin pie \") #f 0.001)\n    (check-within (candidate \"Pumpkin pie 1\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"eeeee e \") #f 0.001)\n    (check-within (candidate \"apple pie\") #f 0.001)\n    (check-within (candidate \"apple pi e \") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction check_if_last_char_is_a_letter(txt){\n  let check = txt.split(' ').pop();\n  return check.length == 1 && check.toLowerCase().charCodeAt(0) >= 97 && check.toLowerCase().charCodeAt(0) <= 122;\n}\n\n### Explanation\n\nThe code is an implementation of a function that checks if the last character of a string is a letter. Here is a line by line explanation of the code:\n\n```function check_if_last_char_is_a_letter(txt){```\n\nThis line defines a function called `check_if_last_char_is_a_letter` that takes one argument, `txt`.\n\n```let check = txt.split(' ').pop();```\n\nThis line creates a variable called `check` and assigns it the value of the last word in the string `txt`. The `split` method is used to split the string into an array of words, and the `pop` method is used to get the last word in the array.\n\n```return check.length == 1 && check.toLowerCase().charCodeAt(0) >= 97 && check.toLowerCase().charCodeAt(0) <= 122;```\n\nThis line returns a boolean value indicating whether the last character of the last word in the string `txt` is a letter. The `length` property is used to check if the last word has only one character. The `toLowerCase` method is used to convert the character to lowercase, and the `charCodeAt` method is used to get the Unicode value of the character. The Unicode values for lowercase letters are between 97 and 122, so the `>=` and `<=` operators are used to check if the Unicode value of the character is within this range.\n\n\n### Racket version\n\n#lang racket\n\n(define (check_if_last_char_is_a_letter txt)\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (iscube a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate iscube))\n    (check-within (candidate 1) #t 0.001)\n    (check-within (candidate 2) #f 0.001)\n    (check-within (candidate -1) #t 0.001)\n    (check-within (candidate 64) #t 0.001)\n    (check-within (candidate 180) #f 0.001)\n    (check-within (candidate 1000) #t 0.001)\n    (check-within (candidate 0) #t 0.001)\n    (check-within (candidate 1729) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction iscube(a){\n  a = Math.abs(a)\n  return Math.round(Math.pow(a, 1/3)) ** 3 == a\n}\n\n### Explanation\n\nThe code is an implementation of a function called `iscube` that takes a single argument `a`. The function returns a boolean value indicating whether `a` is a perfect cube or not.\n\n1. `a = Math.abs(a)` - The absolute value of `a` is assigned to `a`. This is done to ensure that the function works with negative numbers as well.\n2. `Math.pow(a, 1/3)` - The cube root of `a` is calculated using the `Math.pow` function. The second argument, `1/3`, specifies that the cube root is to be calculated.\n3. `Math.round(Math.pow(a, 1/3))` - The cube root of `a` is rounded to the nearest integer using the `Math.round` function.\n4. `Math.round(Math.pow(a, 1/3)) ** 3` - The rounded cube root is cubed using the exponentiation operator `**`.\n5. `Math.round(Math.pow(a, 1/3)) ** 3 == a` - The result of step 4 is compared to `a`. If they are equal, then `a` is a perfect cube and the function returns `true`. Otherwise, the function returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (iscube a)\n"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (reverse_delete s c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_112_reverse_delete.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate reverse_delete))\n    (check-within (candidate \"abcde\" \"ae\") (list \"bcd\" #f) 0.001)\n    (check-within (candidate \"abcdef\" \"b\") (list \"acdef\" #f) 0.001)\n    (check-within (candidate \"abcdedcba\" \"ab\") (list \"cdedc\" #t) 0.001)\n    (check-within (candidate \"dwik\" \"w\") (list \"dik\" #f) 0.001)\n    (check-within (candidate \"a\" \"a\") (list \"\" #t) 0.001)\n    (check-within (candidate \"abcdedcba\" \"\") (list \"abcdedcba\" #t) 0.001)\n    (check-within (candidate \"abcdedcba\" \"v\") (list \"abcdedcba\" #t) 0.001)\n    (check-within (candidate \"vabba\" \"v\") (list \"abba\" #t) 0.001)\n    (check-within (candidate \"mamma\" \"mia\") (list \"\" #t) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction reverse_delete(s, c){\n  s = s.split('').filter(char => !c.includes(char)).join('')\n  return [s, s.split('').reverse().join('') === s]\n}\n\n### Explanation\n\nThe code is an implementation of a function `reverse_delete` that takes two arguments, `s` and `c`. `s` is a string and `c` is an array of characters. The function removes all characters in `c` from `s`, reverses the resulting string and returns a tuple of the resulting string and a boolean indicating whether the resulting string is a palindrome.\n\n1. `s = s.split('').filter(char => !c.includes(char)).join('')`\n   - This line splits the string `s` into an array of characters, filters out all characters that are in the array `c`, and then joins the resulting array back into a string. The resulting string is then assigned to the variable `s`.\n2. `return [s, s.split('').reverse().join('') === s]`\n   - This line returns a tuple containing the resulting string `s` and a boolean indicating whether the resulting string is a palindrome. The boolean is determined by checking whether the reversed string is equal to the original string.\n\n\n### Racket version\n\n#lang racket\n\n(define (reverse_delete s c)\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (mean_absolute_deviation numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mean_absolute_deviation))\n    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction mean_absolute_deviation(numbers){\n  let mean = numbers.reduce((a,b) => a+b) / numbers.length;\n  return numbers.reduce((a,b) => a + Math.abs(b-mean), 0) / numbers.length;\n}\n\n### Explanation\n\nThe code is an implementation of a function that calculates the mean absolute deviation of a list of numbers. \n\n1. The function is called `mean_absolute_deviation` and takes a list of numbers as its argument.\n2. The `mean` variable is defined as the sum of all the numbers in the list divided by the length of the list. This is done using the `reduce` method on the `numbers` array. The `reduce` method takes a function as its argument, which is used to accumulate the sum of all the numbers in the array. The function takes two arguments, `a` and `b`, which represent the accumulated sum and the current element in the array, respectively. The result of the `reduce` method is then divided by the length of the `numbers` array to get the mean.\n3. The `reduce` method is used again on the `numbers` array to calculate the sum of the absolute differences between each number and the mean. This is done using the `Math.abs` function to get the absolute value of the difference between each number and the mean. The `reduce` method takes a function as its argument, which is used to accumulate the sum of the absolute differences. The function takes two arguments, `a` and `b`, which represent the accumulated sum and the current element in the array, respectively. The result of the `reduce` method is then divided by the length of the `numbers` array to get the mean absolute deviation.\n4. The mean absolute deviation is returned as the result of the function.\n\n\n### Racket version\n\n#lang racket\n\n(define (mean_absolute_deviation numbers)\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"<>\") #t 0.001)\n    (check-within (candidate \"<<><>>\") #t 0.001)\n    (check-within (candidate \"<><><<><>><>\") #t 0.001)\n    (check-within (candidate \"<><><<<><><>><>><<><><<>>>\") #t 0.001)\n    (check-within (candidate \"<<<><>>>>\") #f 0.001)\n    (check-within (candidate \"><<>\") #f 0.001)\n    (check-within (candidate \"<\") #f 0.001)\n    (check-within (candidate \"<<<<\") #f 0.001)\n    (check-within (candidate \">\") #f 0.001)\n    (check-within (candidate \"<<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>><<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>>><>\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction correct_bracketing(brackets){\n  let depth = 0;\n  for(let b of brackets){\n    if(b === \"<\"){\n      depth++;\n    }else{\n      depth--;\n    }\n    if(depth < 0){\n      return false;\n    }\n  }\n  return depth === 0;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `correct_bracketing` that takes a string of brackets and returns a boolean indicating whether the brackets are correctly balanced. \n\nThe function starts by initializing a variable called `depth` to 0. \n\nIt then loops through each character in the `brackets` string using a `for...of` loop. \n\nFor each character, it checks if it is an opening bracket (in this case, \"<\"). If it is, it increments the `depth` variable. If it is a closing bracket, it decrements the `depth` variable. \n\nIf at any point the `depth` variable becomes negative, it means there are more closing brackets than opening brackets, and the function immediately returns `false`. \n\nAfter the loop completes, the function checks if the `depth` variable is 0. If it is, it means there are an equal number of opening and closing brackets, and the function returns `true`. If it is not 0, it means there are more opening brackets than closing brackets, and the function returns `false`. \n\n\n### Racket version\n\n#lang racket\n\n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (rescale_to_unit numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)\n    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)\n    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction rescale_to_unit(numbers){\n  let min_number = Math.min(...numbers);\n  let max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n### Explanation\n\nThe code is an implementation of a function called `rescale_to_unit` that takes an array of numbers as input and returns an array of numbers that have been rescaled to the interval [0, 1]. The function works by first finding the minimum and maximum values in the input array using the `Math.min` and `Math.max` functions. It then maps over the input array, subtracting the minimum value from each element and dividing the result by the difference between the maximum and minimum values. This has the effect of rescaling the input values to the interval [0, 1]. The resulting array is then returned.\n\n\n### Racket version\n\n#lang racket\n\n(define (rescale_to_unit numbers)\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (intersection interval1 interval2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersection))\n    (check-within (candidate (list 1 2) (list 2 3)) \"NO\" 0.001)\n    (check-within (candidate (list -1 1) (list 0 4)) \"NO\" 0.001)\n    (check-within (candidate (list -3 -1) (list -5 5)) \"YES\" 0.001)\n    (check-within (candidate (list -2 2) (list -4 0)) \"YES\" 0.001)\n    (check-within (candidate (list -11 2) (list -1 -1)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 3 5)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 1 2)) \"NO\" 0.001)\n    (check-within (candidate (list -2 -2) (list -3 -2)) \"NO\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction intersection(interval1, interval2){\n  function is_prime(num){\n    if(num == 1 || num == 0){\n      return false;\n    }\n    if(num == 2){\n      return true;\n    }\n    for(let i=2; i<num; i++){\n      if(num%i == 0){\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  let l = Math.max(interval1[0], interval2[0]);\n  let r = Math.min(interval1[1], interval2[1]);\n  let length = r - l;\n  if(length > 0 && is_prime(length)){\n    return \"YES\";\n  }\n  return \"NO\";\n}\n\n### Explanation\n\nThe code is an implementation of a function called `intersection` that takes two intervals as input and returns \"YES\" if the length of the intersection between the two intervals is a prime number, and \"NO\" otherwise.\n\nThe function starts by defining a nested function called `is_prime` that takes a number as input and returns true if the number is prime, and false otherwise. The function checks if the input number is 1 or 0, and returns false if it is. If the input number is 2, the function returns true. Otherwise, the function checks if the input number is divisible by any number between 2 and the input number - 1, and returns false if it is. If the function has not returned false at this point, it returns true.\n\nThe `intersection` function then initializes two variables `l` and `r` to the maximum of the first element of the first interval and the first element of the second interval, and the minimum of the second element of the first interval and the second element of the second interval, respectively. These variables represent the left and right endpoints of the intersection between the two intervals.\n\nThe function then calculates the length of the intersection by subtracting `l` from `r`, and stores the result in a variable called `length`.\n\nIf the length of the intersection is greater than 0 and is a prime number (as determined by the `is_prime` function), the function returns \"YES\". Otherwise, it returns \"NO\".<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (intersection interval1 interval2)\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (hex_key num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n    (check-within (candidate \"AB\") 1 0.001)\n    (check-within (candidate \"1077E\") 2 0.001)\n    (check-within (candidate \"ABED1A33\") 4 0.001)\n    (check-within (candidate \"2020\") 2 0.001)\n    (check-within (candidate \"123456789ABCDEF0\") 6 0.001)\n    (check-within (candidate \"112233445566778899AABBCCDDEEFF00\") 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction hex_key(num){\n  let primes = ['2', '3', '5', '7', 'B', 'D'];\n  let total = 0;\n  for(let i=0; i<num.length; i++){\n    if(primes.includes(num[i])){\n      total += 1;\n    }\n  }\n  return total;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `hex_key` that takes a string as an argument. The function returns the number of times a character in the string is a prime number or the letter 'B' or 'D'.\n\n1. `function hex_key(num){}` - This is a function declaration that takes a string argument called `num`.\n2. `let primes = ['2', '3', '5', '7', 'B', 'D'];` - This declares a variable called `primes` and initializes it with an array of prime numbers and the letters 'B' and 'D'.\n3. `let total = 0;` - This declares a variable called `total` and initializes it with the value 0.\n4. `for(let i=0; i<num.length; i++){}` - This is a for loop that iterates over each character in the string `num`.\n5. `if(primes.includes(num[i])){}` - This checks if the current character in the string is included in the `primes` array.\n6. `total += 1;` - If the current character is included in the `primes` array, then the `total` variable is incremented by 1.\n7. `return total;` - This returns the final value of the `total` variable. \n\n\n### Racket version\n\n#lang racket\n\n(define (hex_key num)\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (strange_sort_list lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strange_sort_list))\n    (check-within (candidate (list 1 2 3 4)) (list 1 4 2 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7) 0.001)\n    (check-within (candidate (list 5 5 5 5)) (list 5 5 5 5) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5) 0.001)\n    (check-within (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2) 0.001)\n    (check-within (candidate (list 111111)) (list 111111) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction strange_sort_list(lst){\n  let res = [], switch_ = true;\n  while (lst.length > 0){\n    res.push(switch_ ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.slice(-1)[0]), 1);\n    switch_ = !switch_;\n  }\n  return res;\n}\n\n### Explanation\n\nThe code is an implementation of a sorting algorithm that sorts a list in a strange way. The algorithm sorts the list by alternating between the smallest and largest elements. The algorithm works as follows:\n\n1. Create an empty list called `res` to store the sorted elements.\n2. Create a boolean variable called `switch_` and set it to `true`.\n3. While the length of the input list `lst` is greater than 0, do the following:\n  a. If `switch_` is `true`, find the smallest element in `lst` using the `Math.min` function and add it to the end of `res`. Otherwise, find the largest element in `lst` using the `Math.max` function and add it to the end of `res`.\n  b. Remove the last element of `res` from `lst` using the `splice` function.\n  c. Toggle the value of `switch_` by setting it to the opposite of its current value.\n4. Return the sorted list `res`.\n\n\n### Racket version\n\n#lang racket\n\n(define (strange_sort_list lst)\n"
  },
  {
    "name": "HumanEval_91_is_bored",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_bored S)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_91_is_bored.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n    (check-within (candidate \"Hello world\") 0 0.001)\n    (check-within (candidate \"Is the sky blue?\") 0 0.001)\n    (check-within (candidate \"I love It !\") 1 0.001)\n    (check-within (candidate \"bIt\") 0 0.001)\n    (check-within (candidate \"I feel good today. I will be productive. will kill It\") 2 0.001)\n    (check-within (candidate \"You and I are going for a walk\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_bored(S){\n  let sentences = S.split(/[.?!]\\s*/);\n  return sentences.filter(sentence => sentence.slice(0,2) == 'I ').length;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `is_bored` that takes a string `S` as input and returns the number of sentences in `S` that start with the word \"I\". \n\n1. The first line defines the function `is_bored` with a single parameter `S`.\n2. The second line declares a variable `sentences` and assigns it the result of calling the `split` method on `S`. The `split` method takes a regular expression as an argument and splits the string into an array of substrings where the regular expression matches. In this case, the regular expression matches any period, exclamation point, or question mark followed by zero or more whitespace characters. This effectively splits the string into an array of sentences.\n3. The third line returns the length of the array of sentences that start with the word \"I\". This is accomplished using the `filter` method on the `sentences` array. The `filter` method takes a function as an argument and returns a new array containing only the elements of the original array for which the function returns `true`. In this case, the function is an arrow function that takes a single parameter `sentence` and returns `true` if the first two characters of `sentence` are \"I \" (i.e. \"I \" followed by a space). The `length` property is then called on the resulting array to get the number of sentences that start with \"I\". \n\n\n### Racket version\n\n#lang racket\n\n(define (is_bored S)\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (all_prefixes string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate all_prefixes))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"asdfgh\") (list \"a\" \"as\" \"asd\" \"asdf\" \"asdfg\" \"asdfgh\") 0.001)\n    (check-within (candidate \"WWW\") (list \"W\" \"WW\" \"WWW\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction all_prefixes(string){\n  let result = [];\n  for(let i=0; i<string.length; i++){\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `all_prefixes` that takes a string as an argument and returns a list of all the prefixes of the string. A prefix of a string is a substring that appears at the beginning of the string.\n\n1. The function `all_prefixes` is defined with one parameter `string`.\n2. A variable `result` is defined and initialized to an empty list.\n3. A `for` loop is used to iterate over the indices of the string.\n4. At each iteration, the `slice` method is used to extract the substring from the beginning of the string up to the current index. This substring is then appended to the `result` list using the `push` method.\n5. After the loop has finished iterating over all the indices of the string, the `result` list is returned.\n\n\n### Racket version\n\n#lang racket\n\n(define (all_prefixes string)\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (how_many_times string substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n    (check-within (candidate \"\" \"x\") 0 0.001)\n    (check-within (candidate \"xyxyxyx\" \"x\") 4 0.001)\n    (check-within (candidate \"cacacacac\" \"cac\") 4 0.001)\n    (check-within (candidate \"john doe\" \"john\") 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction how_many_times(string, substring){\n  let times = 0;\n  \n  for(let i=0; i<string.length-substring.length+1; i++){\n    if(string.slice(i, i+substring.length) === substring){\n      times++;\n    }\n  }\n  \n  return times;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `how_many_times` that takes two arguments, `string` and `substring`. The function returns the number of times `substring` appears in `string`.\n\nThe function initializes a variable `times` to 0.\n\nThe function then loops through `string` using a `for` loop. The loop starts at 0 and ends at `string.length-substring.length+1`. This is because the loop needs to stop before it reaches the end of `string` and because the loop needs to check all possible substrings of `string` that are the same length as `substring`.\n\nInside the loop, the function checks if the substring of `string` starting at index `i` and ending at index `i+substring.length` is equal to `substring`. If it is, then `times` is incremented.\n\nFinally, the function returns `times`.\n\n\n### Racket version\n\n#lang racket\n\n(define (how_many_times string substring)\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solution lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solution))\n    (check-within (candidate (list 5 8 7 1)) 12 0.001)\n    (check-within (candidate (list 3 3 3 3 3)) 9 0.001)\n    (check-within (candidate (list 30 13 24 321)) 0 0.001)\n    (check-within (candidate (list 5 9)) 5 0.001)\n    (check-within (candidate (list 2 4 8)) 0 0.001)\n    (check-within (candidate (list 30 13 23 32)) 23 0.001)\n    (check-within (candidate (list 3 13 2 9)) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction solution(lst){\n  return lst.filter((x, i) => i%2 === 0 && x%2 === 1).reduce((a,b) => a+b, 0);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `solution` that takes a list `lst` as input and returns the sum of all odd numbers in the list that are in an odd position (0-based index). \n\nThe function first filters the list to only include elements that are odd and in an odd position. It does this by using the `filter` method on the list object. The `filter` method takes a function as an argument that is used to test each element in the list. The function used here is an arrow function that takes two arguments, `x` and `i`. `x` is the current element being tested and `i` is the index of that element in the list. The function returns `true` if `i` is odd and `x` is odd, and `false` otherwise. \n\nThe `reduce` method is then called on the filtered list to sum all the elements in the list. The `reduce` method takes a function as an argument that is used to accumulate the sum. The function used here is another arrow function that takes two arguments, `a` and `b`. `a` is the accumulated sum so far, and `b` is the current element being added to the sum. The function returns the sum of `a` and `b`. \n\nFinally, the `reduce` method returns the total sum of all the odd elements in the list that are in an odd position. \n\n\n### Racket version\n\n#lang racket\n\n(define (solution lst)\n"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_sorted lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_126_is_sorted.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_sorted))\n    (check-within (candidate (list 5)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 7)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n    (check-within (candidate (list 1)) #t 0.001)\n    (check-within (candidate (list 3 2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 2 2 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 3 3 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 2 3 3 4)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_sorted(lst){\n  let count_digit = {}\n  for (let i of lst){\n    count_digit[i] = (count_digit[i] || 0) + 1\n  }\n  if (lst.some(i => count_digit[i] > 2)){\n    return false\n  }\n  if (lst.slice(1).every((x, i) => x >= lst[i])){\n    return true\n  }\n  else{\n    return false\n  }\n}\n\n### Explanation\n\nThe code is an implementation of a function called `is_sorted` that takes a list of integers as an argument and returns a boolean value indicating whether the list is sorted in non-descending order and no integer appears more than twice. \n\n1. `function is_sorted(lst){}`: This line defines a function called `is_sorted` that takes a list of integers as an argument.\n2. `let count_digit = {}`: This line initializes an empty object called `count_digit` that will be used to count the number of times each integer appears in the list.\n3. `for (let i of lst){count_digit[i] = (count_digit[i] || 0) + 1}`: This line loops through each integer `i` in the list `lst` and updates the count of `i` in the `count_digit` object. If `i` is not already a key in the object, it is initialized to 0 before being incremented.\n4. `if (lst.some(i => count_digit[i] > 2)){return false}`: This line checks if any integer in the list appears more than twice. If so, the function returns `false`.\n5. `if (lst.slice(1).every((x, i) => x >= lst[i])){return true}`: This line checks if the list is sorted in non-descending order. It does this by creating a new list that starts from the second element of `lst` (`lst.slice(1)`) and checking if every element in this new list is greater than or equal to the corresponding element in the original list (`lst[i]`). If so, the function returns `true`.\n6. `else{return false}`: If the list is not sorted in non-descending order, the function returns `false`. \n\n\n### Racket version\n\n#lang racket\n\n(define (is_sorted lst)\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (search lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate search))\n    (check-within (candidate (list 5 5 5 5 1)) 1 0.001)\n    (check-within (candidate (list 4 1 4 1 4 4)) 4 0.001)\n    (check-within (candidate (list 3 3)) -1 0.001)\n    (check-within (candidate (list 8 8 8 8 8 8 8 8)) 8 0.001)\n    (check-within (candidate (list 2 3 3 2 2)) 2 0.001)\n    (check-within (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1)) 1 0.001)\n    (check-within (candidate (list 3 2 8 2)) 2 0.001)\n    (check-within (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1 0.001)\n    (check-within (candidate (list 8 8 3 6 5 6 4)) -1 0.001)\n    (check-within (candidate (list 6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1 0.001)\n    (check-within (candidate (list 1 9 10 1 3)) 1 0.001)\n    (check-within (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10)) 5 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n    (check-within (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4 0.001)\n    (check-within (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2 0.001)\n    (check-within (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1 0.001)\n    (check-within (candidate (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4 0.001)\n    (check-within (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7)) 4 0.001)\n    (check-within (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1)) 2 0.001)\n    (check-within (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8)) -1 0.001)\n    (check-within (candidate (list 10)) -1 0.001)\n    (check-within (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2 0.001)\n    (check-within (candidate (list 5 4 10 2 1 1 10 3 6 1 8)) 1 0.001)\n    (check-within (candidate (list 7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1 0.001)\n    (check-within (candidate (list 3 10 10 9 2)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction search(lst){\n  let frq = Array(Math.max(...lst)+1).fill(0);\n  lst.forEach(i => frq[i]++);\n  \n  let ans = -1;\n  for(let i=1; i<frq.length; i++){\n    if(frq[i] >= i){\n      ans = i;\n    }\n  }\n  \n  return ans;\n}\n\n### Explanation\n\nThe code is an implementation of a search algorithm that finds the smallest integer that is greater than or equal to its frequency in a given list. \n\n1. The `search` function takes a list `lst` as input.\n2. The first line of the function creates an array `frq` of size `Math.max(...lst)+1` and fills it with 0s. This array will be used to keep track of the frequency of each integer in the list.\n3. The second line of the function uses the `forEach` method to iterate over each element `i` in the input list `lst`. For each element, the corresponding index in the `frq` array is incremented by 1.\n4. The third line of the function initializes a variable `ans` to -1. This variable will be used to store the answer.\n5. The fourth line of the function uses a `for` loop to iterate over each index `i` in the `frq` array, starting from 1. \n6. For each index `i`, the `if` statement checks if the frequency of the integer at that index is greater than or equal to the index itself. If so, the `ans` variable is updated to the current index `i`.\n7. Finally, the function returns the `ans` variable, which contains the smallest integer that is greater than or equal to its frequency in the input list. \n\n\n### Racket version\n\n#lang racket\n\n(define (search lst)\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (pluck arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n    (check-within (candidate (list 4 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5 0 3 0 4 2)) (list 0 1) 0.001)\n    (check-within (candidate (list 1 2 3 0 5 3)) (list 0 3) 0.001)\n    (check-within (candidate (list 5 4 8 4 8)) (list 4 1) 0.001)\n    (check-within (candidate (list 7 6 7 1)) (list 6 1) 0.001)\n    (check-within (candidate (list 7 9 7 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction pluck(arr){\n  if(arr.length == 0) return []\n  evens = arr.filter(x => x%2 == 0)\n  if(evens.length == 0) return []\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))]\n}\n\n### Explanation\n\nThe code is an implementation of a function called `pluck` that takes an array of integers as input and returns an array of two integers. The first integer is the smallest even number in the input array, and the second integer is the index of the smallest even number in the input array.\n\n1. `function pluck(arr){`: This line declares the function `pluck` and takes an array `arr` as input.\n2. `if(arr.length == 0) return []`: This line checks if the input array is empty. If it is, the function returns an empty array.\n3. `evens = arr.filter(x => x%2 == 0)`: This line creates a new array called `evens` that contains only the even numbers from the input array. It does this by using the `filter` method to iterate over each element of the input array and only keep the elements that satisfy the condition `x%2 == 0`.\n4. `if(evens.length == 0) return []`: This line checks if the `evens` array is empty. If it is, the function returns an empty array.\n5. `return [Math.min(...evens), arr.indexOf(Math.min(...evens))]`: This line returns an array containing two elements. The first element is the smallest even number in the `evens` array, which is found using the `Math.min` function and the spread operator (`...`). The second element is the index of the smallest even number in the original input array, which is found using the `indexOf` method.\n\n\n### Racket version\n\n#lang racket\n\n(define (pluck arr)\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (pairs_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 5 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 30)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 31)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 30)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 31)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction pairs_sum_to_zero(l){\n  for(let i=0; i<l.length; i++){\n    for(let j=i+1; j<l.length; j++){\n      if(l[i]+l[j] === 0){\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `pairs_sum_to_zero` that takes a list of numbers as an argument and returns a boolean value indicating whether there are two numbers in the list that sum up to zero. \n\n1. The function starts by defining a loop that iterates over the list of numbers. The loop is defined using the `for` keyword and has three parts: an initialization expression (`let i=0`), a condition (`i<l.length`), and an update expression (`i++`). These parts are separated by semicolons. The loop variable `i` is initialized to 0, and the loop will continue as long as `i` is less than the length of the list `l`. The update expression increments `i` by 1 after each iteration of the loop.\n\n2. Inside the first loop, there is another loop that iterates over the remaining elements of the list. This loop is also defined using the `for` keyword, but with a different initialization expression (`let j=i+1`). This ensures that the second loop only considers elements that come after the current element of the first loop. The condition and update expressions are the same as in the first loop.\n\n3. Inside the second loop, there is an `if` statement that checks whether the sum of the current element and the element being considered in the second loop is equal to zero. If this is the case, the function returns `true`, indicating that a pair of elements that sum up to zero has been found.\n\n4. If the loops complete without finding a pair of elements that sum up to zero, the function returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (pairs_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (make_palindrome string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_palindrome))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"x\") \"x\" 0.001)\n    (check-within (candidate \"xyz\") \"xyzyx\" 0.001)\n    (check-within (candidate \"xyx\") \"xyx\" 0.001)\n    (check-within (candidate \"jerry\") \"jerryrrej\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction make_palindrome(string){\n  if (!string) return '';\n\n  let beginning_of_suffix = 0;\n\n  while (string.slice(beginning_of_suffix) !== string.slice(beginning_of_suffix).split('').reverse().join('')){\n    beginning_of_suffix += 1;\n  }\n\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a string and returns a palindrome by appending the reverse of the string's suffix to the original string. Here is a line-by-line explanation:\n\n1. `function make_palindrome(string){`: Defines a function called `make_palindrome` that takes a string as an argument.\n2. `if (!string) return '';`: If the input string is falsy (i.e. empty, null, undefined, etc.), return an empty string.\n3. `let beginning_of_suffix = 0;`: Declare a variable called `beginning_of_suffix` and initialize it to 0.\n4. `while (string.slice(beginning_of_suffix) !== string.slice(beginning_of_suffix).split('').reverse().join('')){`: While the suffix of the string (starting at `beginning_of_suffix`) is not equal to the reverse of that suffix:\n5. `beginning_of_suffix += 1;`: Increment `beginning_of_suffix` by 1.\n6. `}`: End the while loop.\n7. `return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');`: Return the original string concatenated with the reverse of its suffix up to `beginning_of_suffix`.\n\n\n### Racket version\n\n#lang racket\n\n(define (make_palindrome string)\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (starts_one_ends n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 2) 18 0.001)\n    (check-within (candidate 3) 180 0.001)\n    (check-within (candidate 4) 1800 0.001)\n    (check-within (candidate 5) 18000 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction starts_one_ends(n){\n  return n == 1 ? 1 : 18 * (10 ** (n - 2));\n}\n\n### Explanation\n\nThe code is an implementation of a function called `starts_one_ends` that takes a single argument `n`. The function returns 1 if `n` is equal to 1, otherwise it returns 18 times 10 to the power of `n - 2`.\n\nThe `?` and `:` symbols are part of a ternary operator that checks if `n` is equal to 1. If it is, the operator returns 1, otherwise it returns the value on the right of the `:` symbol.\n\nThe `**` symbol is the exponentiation operator in JavaScript. It raises the number on the left to the power of the number on the right.\n\n\n### Racket version\n\n#lang racket\n\n(define (starts_one_ends n)\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_positive l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)\n    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)\n    (check-within (candidate (list -1 -2)) (list ) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction get_positive(l){\n  return l.filter(e => e > 0);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `get_positive` that takes a list as an argument and returns a new list containing only the positive elements of the input list.\n\n1. `function get_positive(l){` - defines a function called `get_positive` that takes a list as an argument.\n2. `return l.filter(e => e > 0);` - returns a new list containing only the elements of the input list that are greater than zero. The `filter` method is called on the input list `l`, and takes a function as an argument that returns `true` if the element should be included in the new list, and `false` otherwise. In this case, the function is an arrow function that takes a single argument `e` and returns `true` if `e` is greater than zero. \n\n\n### Racket version\n\n#lang racket\n\n(define (get_positive l)\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (concatenate strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate concatenate))\n    (check-within (candidate (list )) \"\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"xyz\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\" \"w\" \"k\")) \"xyzwk\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction concatenate(strings){\n  return strings.join('')\n}\n\n### Explanation\n\nThe code is an implementation of a function called `concatenate` that takes an array of strings as an argument. The function returns a new string that is the concatenation of all the strings in the array.\n\nThe `join()` method is called on the `strings` array to concatenate all the strings in the array. The `join()` method concatenates all the elements of an array into a string, separated by a specified separator. If no separator is specified, the default separator is a comma.\n\nThe function returns the concatenated string.\n\n\n### Racket version\n\n#lang racket\n\n(define (concatenate strings)\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_nested string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n    (check-within (candidate \"[[]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]][[[[[]\") #f 0.001)\n    (check-within (candidate \"[][]\") #f 0.001)\n    (check-within (candidate \"[]\") #f 0.001)\n    (check-within (candidate \"[[[[]]]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]]]]]\") #f 0.001)\n    (check-within (candidate \"[][][[]]\") #t 0.001)\n    (check-within (candidate \"[[]\") #f 0.001)\n    (check-within (candidate \"[]]\") #f 0.001)\n    (check-within (candidate \"[[]][[\") #t 0.001)\n    (check-within (candidate \"[[][]]\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"[[[[[[[[\") #f 0.001)\n    (check-within (candidate \"]]]]]]]]\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_nested(string){\n  let opening_bracket_index = [];\n  let closing_bracket_index = [];\n  for(let i=0; i<string.length; i++){\n    if(string[i] === '['){\n      opening_bracket_index.push(i);\n    }else{\n      closing_bracket_index.push(i);\n    }\n  }\n  closing_bracket_index.reverse();\n  let cnt = 0;\n  let i = 0;\n  let l = closing_bracket_index.length;\n  for(let idx of opening_bracket_index){\n    if(i < l && idx < closing_bracket_index[i]){\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2;\n}\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a string is a nested list. \n\n1. The function is defined with the name `is_nested` and takes a single argument `string`.\n2. Two empty arrays are defined to hold the indices of opening and closing brackets in the string.\n3. A `for` loop is used to iterate over each character in the string.\n4. If the character is an opening bracket, its index is added to the `opening_bracket_index` array.\n5. If the character is a closing bracket, its index is added to the `closing_bracket_index` array.\n6. The `closing_bracket_index` array is reversed so that the indices are in the order in which they appear in the string.\n7. Three variables are defined: `cnt` is set to 0, `i` is set to 0, and `l` is set to the length of the `closing_bracket_index` array.\n8. A `for...of` loop is used to iterate over each index in the `opening_bracket_index` array.\n9. If `i` is less than `l` and the current index is less than the index of the closing bracket at index `i` in the `closing_bracket_index` array, `cnt` is incremented and `i` is incremented.\n10. The function returns `true` if `cnt` is greater than or equal to 2, and `false` otherwise.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_nested string)\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_palindrome text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n    (check-within (candidate \"\") #t 0.001)\n    (check-within (candidate \"aba\") #t 0.001)\n    (check-within (candidate \"aaaaa\") #t 0.001)\n    (check-within (candidate \"zbcd\") #f 0.001)\n    (check-within (candidate \"xywyx\") #t 0.001)\n    (check-within (candidate \"xywyz\") #f 0.001)\n    (check-within (candidate \"xywzx\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_palindrome(text){\n  for(let i=0; i<text.length; i++){\n    if(text[i] != text[text.length-1-i]){\n      return false;\n    }\n  }\n  return true;\n}\n\n### Explanation\n\nThe code is an implementation of a function that checks if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward.\n\nThe function takes a string as an argument and returns a boolean value. It returns true if the string is a palindrome and false otherwise.\n\nThe function uses a for loop to iterate over the characters of the string. The loop starts at the first character (i=0) and continues until the last character (i<text.length). The loop increments the value of i by 1 in each iteration.\n\nInside the loop, the function checks if the i-th character of the string is equal to the (text.length-1-i)-th character of the string. If they are not equal, the function returns false, indicating that the string is not a palindrome.\n\nIf the loop completes without returning false, the function returns true, indicating that the string is a palindrome.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_palindrome text)\n"
  },
  {
    "name": "HumanEval_108_count_nums",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_nums arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_108_count_nums.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_nums))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list -1 -2 0)) 0 0.001)\n    (check-within (candidate (list 1 1 2 -2 3 4 5)) 6 0.001)\n    (check-within (candidate (list 1 6 9 -6 0 1 5)) 5 0.001)\n    (check-within (candidate (list 1 100 98 -7 1 -1)) 4 0.001)\n    (check-within (candidate (list 12 23 34 -45 -56 0)) 5 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction count_nums(arr){\n  function digits_sum(n){\n    let neg = 1;\n    if(n < 0){\n      n = -1 * n;\n      neg = -1;\n    }\n    n = Array.from(String(n), Number);\n    n[0] = n[0] * neg;\n    return n.reduce((a,b) => a+b, 0);\n  }\n  return arr.map(digits_sum).filter(x => x > 0).length;\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes an array of integers and returns the count of integers whose digits sum to a positive number. \n\n1. The function `count_nums` takes an array `arr` as input.\n2. The function `digits_sum` takes an integer `n` as input and returns the sum of the digits of `n`.\n3. The variable `neg` is initialized to 1.\n4. If `n` is negative, `n` is multiplied by -1 and `neg` is set to -1.\n5. `n` is converted to an array of digits using `Array.from(String(n), Number)`.\n6. The first digit of `n` is multiplied by `neg`.\n7. The sum of the digits of `n` is computed using `n.reduce((a,b) => a+b, 0)`.\n8. The `digits_sum` function returns the sum of the digits of `n`.\n9. The `count_nums` function maps the `digits_sum` function over the array `arr` using `arr.map(digits_sum)`.\n10. The `filter` method is used to remove all elements of the resulting array that are less than or equal to 0 using `.filter(x => x > 0)`.\n11. The length of the resulting array is returned using `.length`.\n\n\n### Racket version\n\n#lang racket\n\n(define (count_nums arr)\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (factorize n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate factorize))\n    (check-within (candidate 2) (list 2) 0.001)\n    (check-within (candidate 4) (list 2 2) 0.001)\n    (check-within (candidate 8) (list 2 2 2) 0.001)\n    (check-within (candidate 57) (list 3 19) 0.001)\n    (check-within (candidate 3249) (list 3 3 19 19) 0.001)\n    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)\n    (check-within (candidate 20577) (list 3 19 19 19) 0.001)\n    (check-within (candidate 18) (list 2 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction factorize(n){\n  let fact = [];\n  let i = 2;\n  while(i <= Math.sqrt(n) + 1){\n    if(n % i == 0){\n      fact.push(i);\n      n /= i;\n    }else{\n      i++;\n    }\n  }\n  if(n > 1){\n    fact.push(n);\n  }\n  return fact;\n}\n\n### Explanation\n\nThe code is an implementation of a factorization algorithm that takes an integer `n` and returns an array of its prime factors.\n\n1. `function factorize(n){` - defines a function called `factorize` that takes an integer `n` as input.\n2. `let fact = [];` - initializes an empty array called `fact` that will store the prime factors of `n`.\n3. `let i = 2;` - initializes a variable `i` to 2, which will be used to iterate over potential factors of `n`.\n4. `while(i <= Math.sqrt(n) + 1){` - starts a loop that will continue as long as `i` is less than or equal to the square root of `n` plus 1.\n5. `if(n % i == 0){` - checks if `i` is a factor of `n`.\n6. `fact.push(i);` - if `i` is a factor of `n`, it is added to the `fact` array.\n7. `n /= i;` - `n` is divided by `i` to remove the factor from `n`.\n8. `}else{` - if `i` is not a factor of `n`, the `else` block is executed.\n9. `i++;` - `i` is incremented by 1 to check the next potential factor.\n10. `}` - ends the `if/else` block.\n11. `}` - ends the `while` loop.\n12. `if(n > 1){` - checks if there is any remaining factor of `n` that is greater than 1.\n13. `fact.push(n);` - if there is a remaining factor of `n`, it is added to the `fact` array.\n14. `}` - ends the `if` block.\n15. `return fact;` - returns the `fact` array containing the prime factors of `n`.\n\n\n### Racket version\n\n#lang racket\n\n(define (factorize n)\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_prime_factor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n    (check-within (candidate 15) 5 0.001)\n    (check-within (candidate 27) 3 0.001)\n    (check-within (candidate 63) 7 0.001)\n    (check-within (candidate 330) 11 0.001)\n    (check-within (candidate 13195) 29 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction largest_prime_factor(n){\n  function is_prime(k){\n    if(k < 2){\n      return false;\n    }\n    for(let i=2; i<k; i++){\n      if(k % i == 0){\n        return false;\n      }\n    }\n    return true;\n  }\n  let largest = 1;\n  for(let j=2; j<n+1; j++){\n    if(n % j == 0 && is_prime(j)){\n      largest = Math.max(largest, j);\n    }\n  }\n  return largest;\n}\n\n### Explanation\n\nThe code is an implementation of a function that returns the largest prime factor of a given number.\n\n1. `function largest_prime_factor(n){` - declares a function called `largest_prime_factor` that takes a single parameter `n`.\n2. `function is_prime(k){` - declares a nested function called `is_prime` that takes a single parameter `k`.\n3. `if(k < 2){` - checks if `k` is less than 2.\n4. `return false;` - returns `false` if `k` is less than 2.\n5. `for(let i=2; i<k; i++){` - declares a `for` loop that starts at 2 and iterates up to `k-1`.\n6. `if(k % i == 0){` - checks if `k` is divisible by `i`.\n7. `return false;` - returns `false` if `k` is divisible by `i`.\n8. `return true;` - returns `true` if the loop completes without finding a divisor.\n9. `let largest = 1;` - declares a variable called `largest` and initializes it to 1.\n10. `for(let j=2; j<n+1; j++){` - declares a `for` loop that starts at 2 and iterates up to `n`.\n11. `if(n % j == 0 && is_prime(j)){` - checks if `j` is a factor of `n` and if `j` is prime.\n12. `largest = Math.max(largest, j);` - updates `largest` to the maximum value between `largest` and `j`.\n13. `return largest;` - returns the value of `largest`.\n\n\n### Racket version\n\n#lang racket\n\n(define (largest_prime_factor n)\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_max_triples n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_max_triples))\n    (check-within (candidate 5) 1 0.001)\n    (check-within (candidate 6) 4 0.001)\n    (check-within (candidate 10) 36 0.001)\n    (check-within (candidate 100) 53361 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction get_max_triples(n){\n  let A = Array.from({length: n}, (v, i) => (i+1)*(i+1)-i);\n  let ans = [];\n  for(let i=0; i<n; i++){\n    for(let j=i+1; j<n; j++){\n      for(let k=j+1; k<n; k++){\n        if((A[i]+A[j]+A[k])%3 === 0){\n          ans.push([A[i], A[j], A[k]]);\n        }\n      }\n    }\n  }\n  return ans.length;\n}\n\n### Explanation\n\nThe code is an implementation of a function called `get_max_triples` that takes a single integer argument `n`. The function returns the number of triples of numbers in the range 1 to n (inclusive) such that the sum of the squares of the three numbers is divisible by 3.\n\nThe function starts by creating an array `A` of length `n` using the `Array.from` method. The `Array.from` method creates a new array with the specified length and fills it with values returned by the provided function. In this case, the function returns the value `(i+1)*(i+1)-i` for each index `i` in the array. This formula calculates the square of the number `i+1` minus `i`, which is equivalent to `i*i + i + 1`.\n\nThe function then initializes an empty array `ans` to store the triples that satisfy the condition. It then uses three nested loops to iterate over all possible triples of indices in the range `0` to `n-1`. For each triple `(i,j,k)`, it checks if the sum of the squares of the corresponding values in `A` is divisible by 3. If it is, it adds the triple to the `ans` array.\n\nFinally, the function returns the length of the `ans` array, which is the number of triples that satisfy the condition.\n\n\n### Racket version\n\n#lang racket\n\n(define (get_max_triples n)\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (anti_shuffle s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate anti_shuffle))\n    (check-within (candidate \"Hi\") \"Hi\" 0.001)\n    (check-within (candidate \"hello\") \"ehllo\" 0.001)\n    (check-within (candidate \"number\") \"bemnru\" 0.001)\n    (check-within (candidate \"abcd\") \"abcd\" 0.001)\n    (check-within (candidate \"Hello World!!!\") \"Hello !!!Wdlor\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hi. My name is Mister Robot. How are you?\") \".Hi My aemn is Meirst .Rboot How aer ?ouy\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction anti_shuffle(s){\n  return s.split(' ').map(i => [...i].sort().join('')).join(' ');\n}\n\n### Explanation\n\nThe code is an implementation of a function `anti_shuffle` that takes a string `s` as input and returns a string. \n\nThe function splits the input string `s` into an array of words using the `split` method. The `split` method splits a string into an array of substrings based on a specified separator. In this case, the separator is a space character `' '`. \n\nThe `map` method is then called on the array of words. The `map` method creates a new array with the results of calling a provided function on every element in the calling array. In this case, the provided function is an arrow function that takes a word `i` as input. \n\nThe arrow function converts the word `i` into an array of characters using the spread operator `...`. The spread operator allows an iterable such as an array expression or string to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. \n\nThe `sort` method is then called on the array of characters. The `sort` method sorts the elements of an array in place and returns the sorted array. In this case, the `sort` method sorts the characters of the word `i` in alphabetical order. \n\nThe `join` method is then called on the sorted array of characters. The `join` method creates and returns a new string by concatenating all of the elements in an array (or an array-like object), separated by a specified separator string. In this case, the separator string is an empty string `''`. \n\nThe arrow function returns the sorted and joined word `i`. \n\nThe `join` method is then called on the array of sorted and joined words. The `join` method creates and returns a new string by concatenating all of the elements in an array (or an array-like object), separated by a specified separator string. In this case, the separator string is a space character `' '`. \n\nThe `anti_shuffle` function returns the sorted and joined string of words. \n\n\n### Racket version\n\n#lang racket\n\n(define (anti_shuffle s)\n"
  },
  {
    "name": "HumanEval_84_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solve N)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_84_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate 1000) \"1\" 0.001)\n    (check-within (candidate 150) \"110\" 0.001)\n    (check-within (candidate 147) \"1100\" 0.001)\n    (check-within (candidate 333) \"1001\" 0.001)\n    (check-within (candidate 963) \"10010\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction solve(N){\n  return (N+'').split('').reduce((a,b) => +a + +b, 0).toString(2);\n}\n\n### Explanation\n\nThe code is an implementation of a function called `solve` that takes an integer `N` as input and returns a binary string. \n\n1. `return` statement is used to return the output of the function.\n2. `(N+'')` converts the integer `N` to a string.\n3. `.split('')` splits the string into an array of individual characters.\n4. `.reduce((a,b) => +a + +b, 0)` applies a function to each element of the array to reduce it to a single value. The function takes two arguments `a` and `b` and returns the sum of the two. The `+` sign before `a` and `b` converts them to numbers.\n5. `.toString(2)` converts the result of the previous step to a binary string.\n\n\n### Racket version\n\n#lang racket\n\n(define (solve N)\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (minPath grid k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minPath))\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1) 0.001)\n    (check-within (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1) 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1) 0.001)\n    (check-within (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1) 0.001)\n    (check-within (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1) 0.001)\n    (check-within (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6) 0.001)\n    (check-within (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3) 0.001)\n    (check-within (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction minPath(grid, k){\n  let n = grid.length;\n  let val = n * n + 1;\n  for(let i=0; i<n; i++){\n    for(let j=0; j<n; j++){\n      if(grid[i][j] === 1){\n        let temp = [];\n        if(i != 0){\n          temp.push(grid[i-1][j]);\n        }\n        if(j != 0){\n          temp.push(grid[i][j-1]);\n        }\n        if(i != n-1){\n          temp.push(grid[i+1][j]);\n        }\n        if(j != n-1){\n          temp.push(grid[i][j+1]);\n        }\n        val = Math.min(...temp);\n      }\n    }\n  }\n  let ans = [];\n  for(let i=0; i<k; i++){\n    if(i % 2 === 0){\n      ans.push(1);\n    }else{\n      ans.push(val);\n    }\n  }\n  return ans;\n}\n\n### Explanation\n\nThe code is an implementation of a solution to a problem. The problem is to find the minimum path from the top left corner of a grid to the bottom right corner of the grid. The grid is represented by a two-dimensional array of integers. The value of each element in the array represents the cost of moving from that element to the next element. The cost of moving from one element to another is the absolute difference between the values of the two elements.\n\nThe function `minPath` takes two arguments: `grid` and `k`. `grid` is the two-dimensional array representing the grid, and `k` is the number of steps in the path. The function returns an array of integers representing the minimum path.\n\nThe function first initializes two variables: `n` and `val`. `n` is the length of the grid, and `val` is initialized to `n * n + 1`. `val` is used to keep track of the minimum cost of moving from one element to another.\n\nThe function then loops through each element in the grid using two nested `for` loops. For each element, the function checks if the value of the element is `1`. If the value of the element is `1`, the function checks the values of the adjacent elements to the current element. If an adjacent element has a value less than `val`, `val` is updated to the value of the adjacent element.\n\nAfter the loop, the function initializes an empty array `ans`. The function then loops `k` times and adds either `1` or `val` to the `ans` array depending on the index of the loop.\n\nFinally, the function returns the `ans` array.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (minPath grid k)\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (encrypt s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n    (check-within (candidate \"hi\") \"lm\" 0.001)\n    (check-within (candidate \"asdfghjkl\") \"ewhjklnop\" 0.001)\n    (check-within (candidate \"gf\") \"kj\" 0.001)\n    (check-within (candidate \"et\") \"ix\" 0.001)\n    (check-within (candidate \"faewfawefaewg\") \"jeiajeaijeiak\" 0.001)\n    (check-within (candidate \"hellomyfriend\") \"lippsqcjvmirh\" 0.001)\n    (check-within (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" 0.001)\n    (check-within (candidate \"a\") \"e\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction encrypt(s){\n  let d = 'abcdefghijklmnopqrstuvwxyz'\n  let out = ''\n  for (let c of s){\n    if (d.includes(c)){\n      out += d[(d.indexOf(c)+2*2) % 26]\n    } else {\n      out += c\n    }\n  }\n  return out\n}\n\n### Explanation\n\nThe code is an implementation of a simple encryption algorithm. The function `encrypt` takes a string `s` as input and returns an encrypted string. \n\nThe encryption algorithm works as follows:\n1. Define a string `d` that contains all the lowercase letters of the English alphabet.\n2. Create an empty string `out` that will be used to store the encrypted string.\n3. Iterate over each character `c` in the input string `s`.\n4. If the character `c` is a lowercase letter, find its index in the string `d` using the `indexOf` method.\n5. Add `2*2` to the index of the character `c` and take the result modulo `26` to get the index of the encrypted character in the string `d`.\n6. Append the encrypted character to the string `out`.\n7. If the character `c` is not a lowercase letter, append it to the string `out` as is.\n8. Return the encrypted string `out`.\n\n\n### Racket version\n\n#lang racket\n\n(define (encrypt s)\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (make_a_pile n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_a_pile))\n    (check-within (candidate 3) (list 3 5 7) 0.001)\n    (check-within (candidate 4) (list 4 6 8 10) 0.001)\n    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)\n    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)\n    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction make_a_pile(n){\n  return Array.from({length: n}, (_, i) => n + 2*i);\n}\n\n### Explanation\n\nThe code is an implementation of a function that takes a number `n` and returns an array of length `n` with values that increase by 2 for each index. \n\n1. `function make_a_pile(n){}` - declares a function named `make_a_pile` that takes a single argument `n`.\n2. `return Array.from({length: n}, (_, i) => n + 2*i);` - returns an array of length `n` with values that increase by 2 for each index. \n    1. `Array.from` - creates a new array from an array-like object or iterable.\n    2. `{length: n}` - an array-like object with a length property of `n`.\n    3. `(_, i) => n + 2*i` - a function that takes two arguments, the first is the current value of the array, which we don't care about, and the second is the current index. The function returns `n + 2*i`, which is the value for the current index.\n    \n\n### Racket version\n\n#lang racket\n\n(define (make_a_pile n)\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_prime n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 101) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 13441) #t 0.001)\n    (check-within (candidate 61) #t 0.001)\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 1) #f 0.001)\n    (check-within (candidate 5) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 17) #t 0.001)\n    (check-within (candidate 85) #f 0.001)\n    (check-within (candidate 77) #f 0.001)\n    (check-within (candidate 255379) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this JavaScript program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### JavaScript version\n\nfunction is_prime(n){\n  if(n < 2){\n    return false;\n  }\n  for(let k=2; k<n; k++){\n    if(n % k == 0){\n      return false;\n    }\n  }\n  return true;\n}\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a number is prime or not. \n\nThe function takes an integer `n` as input and returns a boolean value. \n\nThe function first checks if the input is less than 2, which is the smallest prime number. If `n` is less than 2, the function returns `false`, since `n` cannot be prime.\n\nIf `n` is greater than or equal to 2, the function enters a loop that iterates from 2 to `n-1`. The loop variable is `k`. \n\nFor each value of `k`, the function checks if `n` is divisible by `k`. If `n` is divisible by `k`, then `n` is not prime and the function returns `false`.\n\nIf the loop completes without finding a value of `k` that divides `n`, then `n` is prime and the function returns `true`.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_prime n)\n"
  }
]