You are a helpful and faithful compiler that transpiles JavaScript code to Racket code. Please translate the following JavaScript code to Racket?

### JavaScript version

function even_odd_palindrome(n){
    function is_palindrome(n){
        return String(n) == String(n).split("").reverse().join("");
    }
    let even_palindrome_count = 0;
    let odd_palindrome_count = 0;
    for(let i = 1; i <= n; i++){
        if(i%2 == 1 && is_palindrome(i)){
            odd_palindrome_count++;
        }else if(i%2 == 0 && is_palindrome(i)){
            even_palindrome_count++;
        }
    }
    return [even_palindrome_count, odd_palindrome_count];
}

### Racket version

#lang racket

;;
(define (even_odd_palindrome n)
  (define (is_palindrome n)
    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))

  (define even_palindrome_count 0)
  (define odd_palindrome_count 0)
  (for ([i (in-range 1 (add1 n))])
    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]
          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))
  (list even_palindrome_count odd_palindrome_count))

### JavaScript version

function is_sorted(lst){
  let count_digit = {}
  for (let i of lst){
    count_digit[i] = (count_digit[i] || 0) + 1
  }
  if (lst.some(i => count_digit[i] > 2)){
    return false
  }
  if (lst.slice(1).every((x, i) => x >= lst[i])){
    return true
  }
  else{
    return false
  }
}

### Racket version

#lang racket

;;
(define (is_sorted lst)
  (define count-digit (make-hash))
  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)
  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)
      #f
      (let loop ([i 1])
        (if (< i (length lst))
            (if (<= (list-ref lst (- i 1)) (list-ref lst i))
                (loop (+ i 1))
                #f)
            #t))))

### JavaScript version

function separate_paren_groups(paren_string){
  let result = [];
  let current_string = [];
  let current_depth = 0;

  for(let c of paren_string){
    if(c === '('){
      current_depth += 1;
      current_string.push(c);
    } else if(c === ')'){
      current_depth -= 1;
      current_string.push(c);

      if(current_depth === 0){
        result.push(current_string.join(''));
        current_string = [];
      }
    }
  }

  return result;
}

### Racket version

#lang racket

;; 
(define (separate_paren_groups paren_string)
  (define result '())
  (define current_string '())
  (define current_depth 0)

  (for ([c (string->list paren_string)])
    (cond [(char=? c #\() (set! current_depth (add1 current_depth))
           (set! current_string (append current_string (list c)))]
          [(char=? c #\)) (set! current_depth (sub1 current_depth))
           (set! current_string (append current_string (list c)))
           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))
                  (set! current_string '())])]))
  result)

### JavaScript version

function sort_array(array){
  return array.length == 0 ? [] : array.sort((a,b)=>(array[0]+array[array.length-1])%2==0 ? b-a : a-b);
}

### Racket version

#lang racket

(define (sort_array array)
  (if (null? array)
      '()
      (sort array (if (even? (+ (first array) (last array))) > <))))

