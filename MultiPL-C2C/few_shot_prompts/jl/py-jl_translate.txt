You are a helpful and faithful compiler that transpiles Python code to Julia code. Please translate the following Python code to Julia?

### Python version

from typing import Tuple

def even_odd_palindrome(n: int) -> Tuple[int, int]:
    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)

### Julia version

function even_odd_palindrome(n::Int64)::Tuple{Int64, Int64}
    function is_palindrome(n::Int64)::Bool
        return string(n) == reverse(string(n))
    end

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in 1:n
        if i%2 == 1 && is_palindrome(i)
            odd_palindrome_count += 1
        elseif i%2 == 0 && is_palindrome(i)
            even_palindrome_count += 1
        end
    end
    return (even_palindrome_count, odd_palindrome_count)
end

### Python version

from typing import List

def is_sorted(lst: List[int]) -> bool:
    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False

### Julia version

function is_sorted(lst::Vector{Int64})::Bool
    count_digit = Dict([(i, 0) for i in lst])
    for i in lst
        count_digit[i]+=1
    end
    if any(count_digit[i] > 2 for i in lst)
        return false
    end
    if all(lst[i-1] <= lst[i] for i in 2:length(lst))
        return true
    else
        return false
    end
end

### Python version

from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result

### Julia version

function separate_paren_groups(paren_string::String)::Vector{String}
    result = []
    current_string = []
    current_depth = 0

    for c in paren_string
        if c == '('
            current_depth += 1
            push!(current_string, c)
        elseif c == ')'
            current_depth -= 1
            push!(current_string, c)

            if current_depth == 0
                push!(result, join(current_string))
                current_string = []
            end
        end
    end

    return result
end

### Python version

from typing import List

def sort_array(array: List[int]) -> List[int]:
    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)

### Julia version

function sort_array(array::Vector{Int64})::Vector{Int64}
    if length(array) == 0
        return []
    else
        return sort(array, rev=(array[1]+array[end]) % 2 == 0)
    end
end
