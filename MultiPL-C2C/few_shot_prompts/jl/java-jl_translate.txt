You are a helpful and faithful compiler that transpiles Java code to Julia code. Please translate the following Java code to Julia?

### Java version

import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    public static Pair<Long, Long> evenOddPalindrome(long n) {
        long evenPalindromeCount = 0;
        long oddPalindromeCount = 0;

        for (long i = 1; i <= n; i++) {
            if (i % 2 == 1 & & isPalindrome(i)) {
                oddPalindromeCount++;
            } else if (i % 2 == 0 & & isPalindrome(i)) {
                evenPalindromeCount++;
            }
        }
        return Pair.with(evenPalindromeCount, oddPalindromeCount);
    }

    private static boolean isPalindrome(long n) {
        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());
    }
}

### Julia version

function even_odd_palindrome(n::Int64)::Tuple{Int64, Int64} 
    function is_palindrome(n)
        return string(n) == reverse(string(n))
    end

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in 1:n
        if i%2 == 1 && is_palindrome(i)
            odd_palindrome_count += 1
        elseif i%2 == 0 && is_palindrome(i)
            even_palindrome_count += 1
        end
    end
    return (even_palindrome_count, odd_palindrome_count)
end

### Java version

import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    public static boolean isSorted(ArrayList<Long> lst) {
        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();
        for (long i : lst) {
            if (count_digit.containsKey(i)) {
                count_digit.put(i, count_digit.get(i) + 1);
            } else {
                count_digit.put(i, 1L);
            }
        }
        for (long i : lst) {
            if (count_digit.get(i) > 2) {
                return false;
            }
        }
        for (int i = 1; i < lst.size(); i++) {
            if (lst.get(i - 1) > lst.get(i)) {
                return false;
            }
        }
        return true;
    }
}

### Julia version

function is_sorted(lst::Vector{Int64})::Bool 
    count_digit = Dict([(i, 0) for i in lst])
    for i in lst
        count_digit[i]+=1
    end
    if any(count_digit[i] > 2 for i in lst)
        return false
    end
    if all(lst[i-1] <= lst[i] for i in 2:length(lst))
        return true
    else
        return false
    end
end

### Java version

import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    public static ArrayList<String> separateParenGroups(String paren_string) {
        ArrayList<String> result = new ArrayList<String>();
        ArrayList<Character> current_string = new ArrayList<Character>();
        int current_depth = 0;

        for (int i = 0; i < paren_string.length(); i++) {
            char c = paren_string.charAt(i);
            if (c == '(') {
                current_depth += 1;
                current_string.add(c);
            } else if (c == ')') {
                current_depth -= 1;
                current_string.add(c);

                if (current_depth == 0) {
                    StringBuilder sb = new StringBuilder(current_string.size());
                    for (Character ch : current_string) {
                        sb.append(ch);
                    }
                    result.add(sb.toString());
                    current_string.clear();
                }
            }
        }

        return result;
    }
}

### Julia version

function separate_paren_groups(paren_string::String)::Vector{String} 
    result = []
    current_string = []
    current_depth = 0

    for c in paren_string
        if c == '('
            current_depth += 1
            push!(current_string, c)
        elseif c == ')'
            current_depth -= 1
            push!(current_string, c)

            if current_depth == 0
                push!(result, join(current_string))
                current_string = []
            end
        end
    end
    return result
end

### Java version

import java.util.*;
import java.lang.reflect.*;
import org.javatuples.*;
import java.security.*;
import java.math.*;
import java.io.*;
import java.util.stream.*;
class Problem {
    public static ArrayList<Long> sortArray(ArrayList<Long> array) {
        if (array.size() == 0) {
            return new ArrayList<Long>();
        } else {
            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;
            Collections.sort(array);
            if (reverse) {
                Collections.reverse(array);
            }
            return array;
        }
    }
}

### Julia version

function sort_array(array::Vector{Int64})::Vector{Int64} 
    return length(array) == 0 ? [] : sort(array, rev=(array[1]+array[end]) % 2 == 0)
end

